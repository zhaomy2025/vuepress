### 问题：异步采样为何不稳定？

- 异步采样 指 JFR 在 不停止业务线程 的情况下，随时抓取线程的调用栈。
- 旧实现直接在任意时刻“爬栈”，会遇到两类崩溃：
1. 线程正好在执行 JIT 刚编译完但尚未完全同步的代码 ，栈帧结构不完整 → 爬栈越界。
2. 线程正在 去优化（deoptimization） 的临界区 → 栈信息不一致。 结果：JVM 偶尔 crash，或者采样数据出现“幽灵栈帧”。

### 旧方案的权衡：要么“安全”要么“失真”

|方案|做法|缺点|
|--|--|--|
|Stop-the-world|让所有线程进入 safepoint 后再采样|业务停顿（几十毫秒），破坏低延迟场景|
|冒险异步|直接爬栈，不做全局停顿|不稳定，可能 JVM 崩溃|

### 新方案：只在 safepoint 采样，但最小化 safepoint 偏差

+ 核心思想
  - 把“采样请求”投递给目标线程，线程自愿在下一个 safepoint 完成采样；采样动作仍由业务线程自己执行，但必须在 safepoint 内完成，保证栈结构一致。
+ 关键机制
  - 协作标志
    * JFR 给每个 Java 线程置位一个`_should_sample_at_safepoint`标志。
  - safepoint 轮询：线程在 safepoint 检查点发现该标志为真，立即：
    * 保存当前 rbp/rsp 等寄存器 → 构建可信栈帧。
    * 把栈信息写入 JFR 缓冲区。
  - 偏差控制
    * 不强制全局停顿：仅对“被采样线程”做一次轻量级 handshake，其他线程继续跑。
    * 时间窗口限制：若线程长时间未进入 safepoint（例如死循环内无 safepoint poll），采样请求超时放弃，避免饥饿。
+ 实现细节
  - Handshakes（JDK 15+ 引入）：单线程级 safepoint，不波及整个 JVM。
  - 偏向采样：默认只采样“运行中”线程，sleep/block 的线程直接跳过，减少无效 safepoint。
  - 自适应阈值：根据历史采样成功率动态调整超时时间，防止过度放弃或过度停顿。

### 一句话总结

JEP 518 把 “安全”与“低延迟” 从对立变为兼得 —— 线程自己走进安全点采样，既保证栈可信，又把停顿缩小到单线程级。