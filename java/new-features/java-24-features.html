<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Java 24 新特性 | My Blog</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="preload" href="/assets/style-CnXJ9Nmb.css" as="style"><link rel="stylesheet" href="/assets/style-CnXJ9Nmb.css">
    <link rel="modulepreload" href="/assets/app-REDOwCgz.js"><link rel="modulepreload" href="/assets/java-24-features.html-1bwQyCQl.js">
    <link rel="prefetch" href="/assets/index.html-CbxtlJvf.js" as="script"><link rel="prefetch" href="/assets/get-started.html-CKDHZTh4.js" as="script"><link rel="prefetch" href="/assets/index.html-3uxycXvg.js" as="script"><link rel="prefetch" href="/assets/git-hooks.html-C9Rpgdss.js" as="script"><link rel="prefetch" href="/assets/git-ssh.html-BDx_iD4w.js" as="script"><link rel="prefetch" href="/assets/index.html-C141MZe5.js" as="script"><link rel="prefetch" href="/assets/index.html-CUSXmWJu.js" as="script"><link rel="prefetch" href="/assets/functools.html-CEh_kX37.js" as="script"><link rel="prefetch" href="/assets/functools_wraps.html-DSymNIFj.js" as="script"><link rel="prefetch" href="/assets/index.html-sS6aZeMD.js" as="script"><link rel="prefetch" href="/assets/requirements.html-bmVkXtp6.js" as="script"><link rel="prefetch" href="/assets/wrapper.html-Ds1i-Br-.js" as="script"><link rel="prefetch" href="/assets/book-name-format.html-Baudvdyt.js" as="script"><link rel="prefetch" href="/assets/book.html-llxDkpVm.js" as="script"><link rel="prefetch" href="/assets/github.html-BCRFfDn3.js" as="script"><link rel="prefetch" href="/assets/index.html-CCpr6y9a.js" as="script"><link rel="prefetch" href="/assets/code_tool_template.html-C99i_Q8n.js" as="script"><link rel="prefetch" href="/assets/index.html-txNQ5LDJ.js" as="script"><link rel="prefetch" href="/assets/tool_template.html-BSz-QfYS.js" as="script"><link rel="prefetch" href="/assets/tutorial_website_setup_template.html-BO7snNDx.js" as="script"><link rel="prefetch" href="/assets/coze.html-DcUkI4Mn.js" as="script"><link rel="prefetch" href="/assets/index.html-BCbPziSx.js" as="script"><link rel="prefetch" href="/assets/instruction.html-B_WFnjiS.js" as="script"><link rel="prefetch" href="/assets/prompt.html-0hSgUy6K.js" as="script"><link rel="prefetch" href="/assets/quesion.html-DnK898t5.js" as="script"><link rel="prefetch" href="/assets/trae-plugin.html-Dr1Lfot7.js" as="script"><link rel="prefetch" href="/assets/github_action.html-QGvZfqG1.js" as="script"><link rel="prefetch" href="/assets/index.html-BCNIV-On.js" as="script"><link rel="prefetch" href="/assets/database-connection-pool.html-Do1v75Jr.js" as="script"><link rel="prefetch" href="/assets/index.html-Cc7HQM_Y.js" as="script"><link rel="prefetch" href="/assets/multithreading.html-BWaHqom-.js" as="script"><link rel="prefetch" href="/assets/multithreading_intro.html-BtxJRzrM.js" as="script"><link rel="prefetch" href="/assets/fastjson2.html-DBGba_ho.js" as="script"><link rel="prefetch" href="/assets/jackson.html-BQvuDpPU.js" as="script"><link rel="prefetch" href="/assets/linked-hash-map-to-object.html-CxPenaQR.js" as="script"><link rel="prefetch" href="/assets/index.html-gkgW5TV0.js" as="script"><link rel="prefetch" href="/assets/java_mail.html-BSFUINr_.js" as="script"><link rel="prefetch" href="/assets/java_mail_sender.html-DegrAgfU.js" as="script"><link rel="prefetch" href="/assets/mail.html-BxE_57qm.js" as="script"><link rel="prefetch" href="/assets/mail_smtp.html--tLgySJ2.js" as="script"><link rel="prefetch" href="/assets/ahead-of-time-method-profiling-intro.html-DHm4mjPX.js" as="script"><link rel="prefetch" href="/assets/compact-object-headers-intro.html-CO7Ml0NJ.js" as="script"><link rel="prefetch" href="/assets/flexible-constructor-bodies-intro.html-DgJyVc1C.js" as="script"><link rel="prefetch" href="/assets/generational-shenandoah-intro.html-DF9VEZEc.js" as="script"><link rel="prefetch" href="/assets/index.html-iqqP4FbW.js" as="script"><link rel="prefetch" href="/assets/java-25-features.html-Cd9vv2w0.js" as="script"><link rel="prefetch" href="/assets/jer-445-463-477-495-512-intro.html-DbvP1RDj.js" as="script"><link rel="prefetch" href="/assets/jfr-cooperative-sampling-intro.html-DgfmPjWv.js" as="script"><link rel="prefetch" href="/assets/module-Import-declarations-intro.html-CXr6yN2o.js" as="script"><link rel="prefetch" href="/assets/prepare-to-restrict-the-use-of-jni-intro.html-_2D1rMnw.js" as="script"><link rel="prefetch" href="/assets/primitive-types-in-patterns-instanceof-and-switch-intro.html-CAzWiQBm.js" as="script"><link rel="prefetch" href="/assets/primitive-types-in-patterns-instanceof-and-switch.html-C3g7cf8T.js" as="script"><link rel="prefetch" href="/assets/stable-values-intro.html-Brx0IIqc.js" as="script"><link rel="prefetch" href="/assets/index.html-Cj2_kCol.js" as="script"><link rel="prefetch" href="/assets/mybatis-annotation.html-DBQz7xpj.js" as="script"><link rel="prefetch" href="/assets/mybatis-intro.html-Fz9vYoZh.js" as="script"><link rel="prefetch" href="/assets/mybatis-plus-code-generator.html-Bij_b_cy.js" as="script"><link rel="prefetch" href="/assets/mybatis-plus-multi-tenant.html-C413kSt1.js" as="script"><link rel="prefetch" href="/assets/mybatis-plus-pagehelper.html-F1Ua4z7y.js" as="script"><link rel="prefetch" href="/assets/mybatis.html-ChuCBtfk.js" as="script"><link rel="prefetch" href="/assets/apache_common.html-DeOJqADe.js" as="script"><link rel="prefetch" href="/assets/file.html-DK0kBxwg.js" as="script"><link rel="prefetch" href="/assets/file_utils.html-DWeGUrab.js" as="script"><link rel="prefetch" href="/assets/hutool.html-C0gO8uUn.js" as="script"><link rel="prefetch" href="/assets/index.html-Cjcn8g6g.js" as="script"><link rel="prefetch" href="/assets/index.html-g92nsIwF.js" as="script"><link rel="prefetch" href="/assets/dynamic-programming-intro.html-CrEHJRdG.js" as="script"><link rel="prefetch" href="/assets/dynamic-programming.html-COkQCHMb.js" as="script"><link rel="prefetch" href="/assets/index.html-D_I1J084.js" as="script"><link rel="prefetch" href="/assets/index.html-yCwwsbL2.js" as="script"><link rel="prefetch" href="/assets/index.html-CyNlzIZK.js" as="script"><link rel="prefetch" href="/assets/index.html-DxY46N4X.js" as="script"><link rel="prefetch" href="/assets/nvm.html-CdMfd7s8.js" as="script"><link rel="prefetch" href="/assets/command.html-Db0DZ1uN.js" as="script"><link rel="prefetch" href="/assets/index.html-CqQs6Xk6.js" as="script"><link rel="prefetch" href="/assets/index.html-DJxOJA_W.js" as="script"><link rel="prefetch" href="/assets/spring-boot-hello-world-intro.html-CgLU2q1w.js" as="script"><link rel="prefetch" href="/assets/spring-boot-hello-world.html-DTtgbT2N.js" as="script"><link rel="prefetch" href="/assets/spring-boot-oracle.html-DxUaWDUp.js" as="script"><link rel="prefetch" href="/assets/spring-boot-redis-intro.html-BbGeDXZM.js" as="script"><link rel="prefetch" href="/assets/spring-boot-redis.html-nY1UVZT9.js" as="script"><link rel="prefetch" href="/assets/spring-boot.html-UaA-wg8r.js" as="script"><link rel="prefetch" href="/assets/spring-framework-aop-impi.html-DG1sIvIB.js" as="script"><link rel="prefetch" href="/assets/spring-framework-aop.html-CfzFYO9c.js" as="script"><link rel="prefetch" href="/assets/spring-framework-ioc-impi.html-BpzVggUL.js" as="script"><link rel="prefetch" href="/assets/spring-framework-ioc.html-B7nmfhOS.js" as="script"><link rel="prefetch" href="/assets/spring-framework.html-CO4uWVJy.js" as="script"><link rel="prefetch" href="/assets/common_markdown.html-DQy_feEP.js" as="script"><link rel="prefetch" href="/assets/common_summary.html-D7imODUZ.js" as="script"><link rel="prefetch" href="/assets/css.html-B5xMVGvC.js" as="script"><link rel="prefetch" href="/assets/index.html-Dk08wN-1.js" as="script"><link rel="prefetch" href="/assets/plugin.html-BedsZ1UJ.js" as="script"><link rel="prefetch" href="/assets/vue-component.html-CetF-4y-.js" as="script"><link rel="prefetch" href="/assets/vuepress_cloud.html-Bbd7TZkO.js" as="script"><link rel="prefetch" href="/assets/index.html-DtRP2Qzy.js" as="script"><link rel="prefetch" href="/assets/requirement_v1.html-0DGt0bKc.js" as="script"><link rel="prefetch" href="/assets/index.html-edUGYd38.js" as="script"><link rel="prefetch" href="/assets/itexpdf.html-DHRShreQ.js" as="script"><link rel="prefetch" href="/assets/index.html-DtTd1Szd.js" as="script"><link rel="prefetch" href="/assets/load-balance.html-C6XS5FSy.js" as="script"><link rel="prefetch" href="/assets/suggest.html-ungotpGl.js" as="script"><link rel="prefetch" href="/assets/client.html-CcSmbFL-.js" as="script"><link rel="prefetch" href="/assets/command.html-BlM5ma9O.js" as="script"><link rel="prefetch" href="/assets/curator.html-DAiQvHFd.js" as="script"><link rel="prefetch" href="/assets/index.html-Dzw4ybk5.js" as="script"><link rel="prefetch" href="/assets/zkclient.html-CGKiHEpE.js" as="script"><link rel="prefetch" href="/assets/zookeeper_intro.html-CKzfB9Vu.js" as="script"><link rel="prefetch" href="/assets/index.html-DYIxJyya.js" as="script"><link rel="prefetch" href="/assets/multi-tenant.html-BumwOke0.js" as="script"><link rel="prefetch" href="/assets/constraint.html-Batgub5d.js" as="script"><link rel="prefetch" href="/assets/cursor.html-H8L8itn9.js" as="script"><link rel="prefetch" href="/assets/cursor_intro.html-CDGMpcqU.js" as="script"><link rel="prefetch" href="/assets/index.html-BAHN_wfg.js" as="script"><link rel="prefetch" href="/assets/index.html-CG0Yh8pE.js" as="script"><link rel="prefetch" href="/assets/tencent-nginx.html-C3kh11CZ.js" as="script"><link rel="prefetch" href="/assets/tencent.html-Oqrc2YrD.js" as="script"><link rel="prefetch" href="/assets/index.html-BLXSItg6.js" as="script"><link rel="prefetch" href="/assets/nginx-problem.html-B_w2XD9S.js" as="script"><link rel="prefetch" href="/assets/nginx.html-B4pSJ8Q9.js" as="script"><link rel="prefetch" href="/assets/index.html-KgiJjeiU.js" as="script"><link rel="prefetch" href="/assets/snowflake.html-CZluR8_r.js" as="script"><link rel="prefetch" href="/assets/index.html-Bh2A9DGZ.js" as="script"><link rel="prefetch" href="/assets/404.html-dyZrbNbE.js" as="script"><link rel="prefetch" href="/assets/index.html-BeNHZuNB.js" as="script"><link rel="prefetch" href="/assets/index.html-Dnc1Yjva.js" as="script"><link rel="prefetch" href="/assets/index.html-hSRFumGy.js" as="script"><link rel="prefetch" href="/assets/index.html-DuBXtvku.js" as="script"><link rel="prefetch" href="/assets/index.html-DBlOn_Zv.js" as="script"><link rel="prefetch" href="/assets/index.html-C6HuXeR9.js" as="script"><link rel="prefetch" href="/assets/index.html-CrpWFASO.js" as="script"><link rel="prefetch" href="/assets/index.html-BU3xYT-W.js" as="script"><link rel="prefetch" href="/assets/index.html-DizHckp1.js" as="script"><link rel="prefetch" href="/assets/index.html-BuuzlROI.js" as="script"><link rel="prefetch" href="/assets/index.html-CZoUdVP6.js" as="script"><link rel="prefetch" href="/assets/index.html-DswwyVEX.js" as="script"><link rel="prefetch" href="/assets/index.html-CIuAurgV.js" as="script"><link rel="prefetch" href="/assets/index.html-CQDVI2Xo.js" as="script"><link rel="prefetch" href="/assets/index.html-Dd1MM3MI.js" as="script"><link rel="prefetch" href="/assets/index.html-Brz3Xobx.js" as="script"><link rel="prefetch" href="/assets/index.html-DwTvLJ4V.js" as="script"><link rel="prefetch" href="/assets/index.html-CIuAurgV.js" as="script"><link rel="prefetch" href="/assets/index.html-CQDVI2Xo.js" as="script"><link rel="prefetch" href="/assets/index.html-BwKc80jq.js" as="script"><link rel="prefetch" href="/assets/index.html-DddmT-Nd.js" as="script"><link rel="prefetch" href="/assets/index.html-BvMFjwN5.js" as="script"><link rel="prefetch" href="/assets/index.html-DqFCUb-4.js" as="script"><link rel="prefetch" href="/assets/index.html-icXUZVKe.js" as="script"><link rel="prefetch" href="/assets/index.html-GWBIHtjB.js" as="script"><link rel="prefetch" href="/assets/index.html-CwUTtBO4.js" as="script"><link rel="prefetch" href="/assets/index.html-JQKjGMdR.js" as="script"><link rel="prefetch" href="/assets/index.html-mVyT3cV2.js" as="script"><link rel="prefetch" href="/assets/index.html-X5iA1Rt0.js" as="script"><link rel="prefetch" href="/assets/index.html-4biW6DSP.js" as="script"><link rel="prefetch" href="/assets/index.html-vZMQn4cQ.js" as="script"><link rel="prefetch" href="/assets/index.html-Cd458p3n.js" as="script"><link rel="prefetch" href="/assets/index.html-CMrkuxin.js" as="script"><link rel="prefetch" href="/assets/index.html-s0lcxELg.js" as="script"><link rel="prefetch" href="/assets/index.html-B1LRVvuG.js" as="script"><link rel="prefetch" href="/assets/index.html-W78YjJxu.js" as="script"><link rel="prefetch" href="/assets/index.html-Dzf-is9x.js" as="script"><link rel="prefetch" href="/assets/index.html-B3wC-F9i.js" as="script"><link rel="prefetch" href="/assets/index.html-C7SOGAaj.js" as="script"><link rel="prefetch" href="/assets/index.html-CQhNqjSk.js" as="script"><link rel="prefetch" href="/assets/index.html-BIXqfZlJ.js" as="script"><link rel="prefetch" href="/assets/index.html-CTWCWqN2.js" as="script"><link rel="prefetch" href="/assets/index.html-D2D57BSb.js" as="script"><link rel="prefetch" href="/assets/index.html-1wwb7BZi.js" as="script"><link rel="prefetch" href="/assets/index.html-CUakD9Iv.js" as="script"><link rel="prefetch" href="/assets/index.html-DOR4wVxg.js" as="script"><link rel="prefetch" href="/assets/index.html-CGT7HzCz.js" as="script"><link rel="prefetch" href="/assets/mermaid.esm.min-Bjh7LXza.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="/images/logo.png" alt="My Blog"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">My Blog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/resource/" aria-label="资源"><!--[--><!--[--><!--]--><!--]-->资源<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/java_script/" aria-label="JavaScript"><!--[--><!--[--><!--]--><!--]-->JavaScript<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/java/" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/spring/" aria-label="Spring"><!--[--><!--[--><!--]--><!--]-->Spring<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/arch/" aria-label="架构"><!--[--><!--[--><!--]--><!--]-->架构<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/db/" aria-label="数据库"><!--[--><!--[--><!--]--><!--]-->数据库<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/algorithm/" aria-label="算法"><!--[--><!--[--><!--]--><!--]-->算法<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/linux/" aria-label="Linux"><!--[--><!--[--><!--]--><!--]-->Linux<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/git/" aria-label="Git"><!--[--><!--[--><!--]--><!--]-->Git<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/vuepress/" aria-label="VuePress"><!--[--><!--[--><!--]--><!--]-->VuePress<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/others/" aria-label="杂项"><!--[--><!--[--><!--]--><!--]-->杂项<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/ai/" aria-label="AI"><!--[--><!--[--><!--]--><!--]-->AI<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/resource/" aria-label="资源"><!--[--><!--[--><!--]--><!--]-->资源<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/java_script/" aria-label="JavaScript"><!--[--><!--[--><!--]--><!--]-->JavaScript<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/java/" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/spring/" aria-label="Spring"><!--[--><!--[--><!--]--><!--]-->Spring<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/arch/" aria-label="架构"><!--[--><!--[--><!--]--><!--]-->架构<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/db/" aria-label="数据库"><!--[--><!--[--><!--]--><!--]-->数据库<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/algorithm/" aria-label="算法"><!--[--><!--[--><!--]--><!--]-->算法<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/linux/" aria-label="Linux"><!--[--><!--[--><!--]--><!--]-->Linux<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/git/" aria-label="Git"><!--[--><!--[--><!--]--><!--]-->Git<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/vuepress/" aria-label="VuePress"><!--[--><!--[--><!--]--><!--]-->VuePress<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/others/" aria-label="杂项"><!--[--><!--[--><!--]--><!--]-->杂项<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/ai/" aria-label="AI"><!--[--><!--[--><!--]--><!--]-->AI<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item vp-sidebar-heading" href="/java/" aria-label="Java"><!--[--><!--[--><!--]--><!--]-->Java<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item vp-sidebar-heading active" href="/java/new-features/" aria-label="Java 新特性"><!--[--><!--[--><!--]--><!--]-->Java 新特性<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/new-features/java-25-features.html" aria-label="Java 25 新特性"><!--[--><!--[--><!--]--><!--]-->Java 25 新特性<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/java/new-features/java-24-features.html" aria-label="Java 24 新特性"><!--[--><!--[--><!--]--><!--]-->Java 24 新特性<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item vp-sidebar-heading" href="/java/intermediate/" aria-label="Java 中级"><!--[--><!--[--><!--]--><!--]-->Java 中级<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/intermediate/multithreading.html" aria-label="Java 多线程编程"><!--[--><!--[--><!--]--><!--]-->Java 多线程编程<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">工具库 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/utils/file_utils.html" aria-label="FileUtils"><!--[--><!--[--><!--]--><!--]-->FileUtils<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/utils/pdf_utils/" aria-label="PDFUtils"><!--[--><!--[--><!--]--><!--]-->PDFUtils<!--[--><!--[--><!--]--><!--]--></a><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/utils/pdf_utils/itexpdf.html" aria-label="itexpdf"><!--[--><!--[--><!--]--><!--]-->itexpdf<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/utils/apache_common.html" aria-label="Apache Common"><!--[--><!--[--><!--]--><!--]-->Apache Common<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/utils/hutool.html" aria-label="hutool"><!--[--><!--[--><!--]--><!--]-->hutool<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Json <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/json/fastjson2.html" aria-label="fastjson2"><!--[--><!--[--><!--]--><!--]-->fastjson2<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/json/jackson.html" aria-label="Jackson库详解"><!--[--><!--[--><!--]--><!--]-->Jackson库详解<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">ORM <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/orm/mybatis.html" aria-label="MyBatis"><!--[--><!--[--><!--]--><!--]-->MyBatis<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/orm/mybatis-annotation.html" aria-label="MyBatis/MyBatis-Plus注解"><!--[--><!--[--><!--]--><!--]-->MyBatis/MyBatis-Plus注解<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">模块 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/module/mail.html" aria-label="Java 邮件服务"><!--[--><!--[--><!--]--><!--]-->Java 邮件服务<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/module/java_mail.html" aria-label="JavaMail"><!--[--><!--[--><!--]--><!--]-->JavaMail<!--[--><!--[--><!--]--><!--]--></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/java/module/java_mail_sender.html" aria-label="JavaMailSender"><!--[--><!--[--><!--]--><!--]-->JavaMailSender<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">其他 <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/java/misc/linked-hash-map-to-object.html" aria-label="LinkedHashMap解析"><!--[--><!--[--><!--]--><!--]-->LinkedHashMap解析<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><h1 id="java-24-新特性" tabindex="-1"><a class="header-anchor" href="#java-24-新特性"><span>Java 24 新特性</span></a></h1><nav class="table-of-contents"><ul><li><a aria-current="page" href="/java/new-features/java-24-features.html#概述" class="router-link-active router-link-exact-active">概述</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-404-分代-shenandoah-实验性" class="router-link-active router-link-exact-active">JEP 404: 分代 Shenandoah（实验性）</a><ul><li><a aria-current="page" href="/java/new-features/java-24-features.html#核心目标" class="router-link-active router-link-exact-active">核心目标</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#工作原理" class="router-link-active router-link-exact-active">工作原理</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#启用方式" class="router-link-active router-link-exact-active">启用方式</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#适用场景" class="router-link-active router-link-exact-active">适用场景</a></li></ul></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-450-紧凑对象头-实验性" class="router-link-active router-link-exact-active">JEP 450: 紧凑对象头（实验性）</a><ul><li><a aria-current="page" href="/java/new-features/java-24-features.html#核心原理" class="router-link-active router-link-exact-active">核心原理</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#新旧对象头布局对比" class="router-link-active router-link-exact-active">新旧对象头布局对比</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#启用方式-1" class="router-link-active router-link-exact-active">启用方式</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#适用场景-1" class="router-link-active router-link-exact-active">适用场景</a></li></ul></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-472-准备限制-jni-的使用" class="router-link-active router-link-exact-active">JEP 472: 准备限制 JNI 的使用</a><ul><li><a aria-current="page" href="/java/new-features/java-24-features.html#核心目标-1" class="router-link-active router-link-exact-active">核心目标</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#动机与背景" class="router-link-active router-link-exact-active">动机与背景</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#核心变化" class="router-link-active router-link-exact-active">核心变化</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#未来计划" class="router-link-active router-link-exact-active">未来计划</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#重要说明" class="router-link-active router-link-exact-active">重要说明</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#总结" class="router-link-active router-link-exact-active">总结</a></li></ul></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-475-g1-的-late-barrier-扩展" class="router-link-active router-link-exact-active">JEP 475: G1 的 Late Barrier 扩展</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-478-密钥派生函数-api-预览" class="router-link-active router-link-exact-active">JEP 478: 密钥派生函数 API（预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-479-删除-windows-32-位-x86-端口" class="router-link-active router-link-exact-active">JEP 479: 删除 Windows 32 位 x86 端口</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-483-提前类加载和链接" class="router-link-active router-link-exact-active">JEP 483: 提前类加载和链接</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-484-类文件-api" class="router-link-active router-link-exact-active">JEP 484: 类文件 API</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-485-流收集器" class="router-link-active router-link-exact-active">JEP 485: 流收集器</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-486-永久禁用安全管理器" class="router-link-active router-link-exact-active">JEP 486: 永久禁用安全管理器</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-487-范围值-第四个预览版" class="router-link-active router-link-exact-active">JEP 487: 范围值（第四个预览版）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-488-模式、instanceof-和-switch中的原始类型-第二次预览" class="router-link-active router-link-exact-active">JEP 488: 模式、instanceof 和 switch中的原始类型（第二次预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-489-向量-api-第九个孵化器" class="router-link-active router-link-exact-active">JEP 489: 向量 API（第九个孵化器）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-490-zgc-删除非分代模式" class="router-link-active router-link-exact-active">JEP 490: ZGC：删除非分代模式</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-491-无需固定即可同步虚拟线程" class="router-link-active router-link-exact-active">JEP 491: 无需固定即可同步虚拟线程</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-492-灵活的构造函数体-第三次预览" class="router-link-active router-link-exact-active">JEP 492: 灵活的构造函数体（第三次预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-493-无需-jmod-即可链接运行时图像" class="router-link-active router-link-exact-active">JEP 493: 无需 JMOD 即可链接运行时图像</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-494-模块导入声明-第二次预览" class="router-link-active router-link-exact-active">JEP 494: 模块导入声明（第二次预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-495-简单源文件和实例主要方法-第四次预览" class="router-link-active router-link-exact-active">JEP 495: 简单源文件和实例主要方法（第四次预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-496-基于抗量子模块格的密钥封装机制-jep-497-基于模块格的抗量子数字签名算法" class="router-link-active router-link-exact-active">JEP 496: 基于抗量子模块格的密钥封装机制 &amp; JEP 497: 基于模块格的抗量子数字签名算法</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告" class="router-link-active router-link-exact-active">JEP 498: 在 sun.misc.Unsafe 中使用内存访问方法时发出警告</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-499-结构化并发-第四次预览" class="router-link-active router-link-exact-active">JEP 499: 结构化并发（第四次预览）</a></li><li><a aria-current="page" href="/java/new-features/java-24-features.html#jep-501-弃用-32-位-x86-端口并将其删除" class="router-link-active router-link-exact-active">JEP 501: 弃用 32 位 x86 端口并将其删除</a></li></ul></nav><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>Java 24 于 2025 年 3 月发布，包含了多个新特性和改进。</p><h2 id="jep-404-分代-shenandoah-实验性" tabindex="-1"><a class="header-anchor" href="#jep-404-分代-shenandoah-实验性"><span>JEP 404: 分代 Shenandoah（实验性）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 404: Generational Shenandoah (Experimental)</p><p>Enhance the Shenandoah garbage collector with experimental generational collection capabilities to improve sustainable throughput, load-spike resilience, and memory utilization.</p></div><p>通过实验性分代收集功能增强 Shenandoah 垃圾回收器 ，以提高可持续吞吐量、负载峰值弹性和内存利用率。</p><h3 id="核心目标" tabindex="-1"><a class="header-anchor" href="#核心目标"><span>核心目标</span></a></h3><p>在保持Shenandoah原有的<strong>低暂停时间优势</strong>基础上，进一步<strong>减少内存占用和CPU开销</strong>。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><p>将堆内存划分为年轻代和老年代，优先且更频繁地收集年轻代（通常包含大量短生命周期对象），避免其过早晋升到老年代，减少全局垃圾回收的需要。</p><ul><li>新生代专用回收策略：采用复制篡法快速回收短生命周期对象，减少老年代扫描频率</li><li>卡表 (Card Table) 优化：精确记录老年代到新生代的跨代引用，降低 GC 停顿时间 30 ％以上</li><li>井行标记增强：在并发标记阶段优先处理新生代区域，使平均 GC 暂停时间控制在 2ms 以内。实测表明，在 16GB 堆内存的微服务场景下，分代 Shenandoah 相比原版吞吐量提升 40 ％，同时保持亚毫秒级的最大暂停时间，成为低延迟应用的理想选择。</li></ul><h3 id="启用方式" tabindex="-1"><a class="header-anchor" href="#启用方式"><span>启用方式</span></a></h3><p>需添加JVM参数：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UnlockExperimentalVMOptions</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">ShenandoahGCMode</span><span class="token operator">=</span>generational</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>低延迟高响应应用：例如实时交易系统、交互式数据分析平台。</li><li>大量短生命周期对象：例如处理大量临时请求或缓存数据的应用。</li><li>关注内存效率：希望降低垃圾收集器内存开销和CPU使用率的应用。</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><ul><li>Shenandoah GC最初在JDK 12中作为实验性功能引入，其最大特点是通过与应用程序线程并发执行大部分工作来尽可能减少GC暂停时间，且暂停时间与堆大小无关。</li><li>后在JDK 15中，Shenandoah GC从实验性功能转为正式的生产功能，不再需要额外的解锁实验参数，但其默认的垃圾收集器仍然是G1。</li><li>分代Shenandoah旨在与G1、ZGC（JEP 439已为ZGC引入分代模式）等现代收集器同步发展，同时保持自身在最小化延迟方面的独特优势。</li></ul></div><h2 id="jep-450-紧凑对象头-实验性" tabindex="-1"><a class="header-anchor" href="#jep-450-紧凑对象头-实验性"><span>JEP 450: 紧凑对象头（实验性）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 450: Compact Object Headers (Experimental)</p><p>Reduce the size of object headers in the HotSpot JVM from between 96 and 128 bits down to 64 bits on 64-bit architectures. This will reduce heap size, improve deployment density, and increase data locality.</p></div><p>重构了Java对象的内存布局，将 HotSpot JVM中的普通对象头大小从96到128位减少到64位，从而提升内存利用率和应用性能。</p><h3 id="核心原理" tabindex="-1"><a class="header-anchor" href="#核心原理"><span>核心原理</span></a></h3><p>Java 对象在堆中的存储包含<strong>对象头</strong>和<strong>实例数据</strong>。对象头又分为：</p><ul><li><strong>标记字 (Mark Word)</strong>：存储哈希码、GC 年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等运行时数据。</li><li><strong>类指针 (Class Pointer)</strong>：指向对象的类元数据。</li><li><strong>数组长度</strong>：数组对象的头部还会额外包含该字段。</li></ul><p>在 64 位 JVM 中，普通对象头通常占 <strong>12字节（96位） 至 16字节（128位）</strong>。对于许多平均大小仅为 32-64 字节的小对象来说，对象头的开销占比非常高，可能达到 <strong>20% 到 50%</strong>。JEP 450 通过以下方式将对象头压缩至 <strong>64 位 (8 字节)</strong>：</p><ul><li><strong>压缩类指针</strong>：将原本 32 位的压缩类指针进一步优化为 <strong>22 位</strong>，并将其编码嵌入标记字中。</li><li><strong>标记字的功能重组与升级</strong>：对固定的 64 位标记字空间进行了彻底的重新规划，将其划分为一个精细的功能位域集合，以同时承载原有和新增的信息</li><li><strong>锁机制革新</strong>：传统的<strong>偏向锁</strong> 和<strong>轻量级锁</strong> 会覆盖整个标记字（除锁标记位外），与紧凑对象头中必须保留类指针的设计冲突。因此，<strong>紧凑对象头不再支持偏向锁和栈锁</strong>。它依赖 <strong>JDK 22 中引入的对象监视表</strong> 来管理重量级锁信息。</li></ul><h3 id="新旧对象头布局对比" tabindex="-1"><a class="header-anchor" href="#新旧对象头布局对比"><span>新旧对象头布局对比</span></a></h3><p>为了更直观地理解其变化，可以参考下表对传统对象头与紧凑对象头进行的对比：</p><h4 id="java传统对象头" tabindex="-1"><a class="header-anchor" href="#java传统对象头"><span>Java传统对象头</span></a></h4><p><strong>传统对象头大小</strong></p><table><thead><tr><th style="text-align:left;">是否压缩</th><th style="text-align:left;">对象类型</th><th style="text-align:left;">大小</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">压缩</td><td style="text-align:left;">普通对象</td><td style="text-align:left;">12字节（96位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针4B（32位）</td></tr><tr><td style="text-align:left;">压缩</td><td style="text-align:left;">数组对象</td><td style="text-align:left;">16字节（128位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针4B（32位）<br>+ 数组长度4B（32位）</td></tr><tr><td style="text-align:left;">未压缩</td><td style="text-align:left;">普通对象</td><td style="text-align:left;">16字节（128位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针8B（64位）</td></tr><tr><td style="text-align:left;">未压缩</td><td style="text-align:left;">数组对象</td><td style="text-align:left;">20字节（160位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针8B（64位）<br>+ 数组长度4B（32位）</td></tr></tbody></table><p><strong>传统对象头标记字（Mark Word）</strong></p><table><thead><tr><th>状态</th><th>锁状态</th><th>偏向锁</th><th>GC分代<br>年龄</th><th>未使用</th><th>其他</th></tr></thead><tbody><tr><td>无锁状态</td><td>01</td><td>0</td><td>4位</td><td>1位</td><td>哈希码（31位）+ 未使用（25位）</td></tr><tr><td>偏向锁状态</td><td>01</td><td>1</td><td>4位</td><td>1位</td><td>线程ID（54位）+ epoch（2位）</td></tr><tr><td>轻量级锁状态</td><td>00</td><td colspan="4">指向锁记录的指针（62位）</td></tr><tr><td>重量级锁状态</td><td>10</td><td colspan="4">指向Monitor的指针（62位）</td></tr><tr><td>GC 分代年龄</td><td>11</td><td colspan="4">GC所需标记信息</td></tr></tbody></table><h4 id="紧凑对象头" tabindex="-1"><a class="header-anchor" href="#紧凑对象头"><span>紧凑对象头</span></a></h4><table><thead><tr><th style="text-align:left;">标记位</th><th style="text-align:left;">自转发标记位</th><th style="text-align:left;">GC分代年龄</th><th style="text-align:left;">预留</th><th style="text-align:left;">哈希码</th><th style="text-align:left;">压缩类指针</th></tr></thead><tbody><tr><td style="text-align:left;">2位</td><td style="text-align:left;">1位</td><td style="text-align:left;">4位</td><td style="text-align:left;">4位</td><td style="text-align:left;">31位</td><td style="text-align:left;">22位</td></tr></tbody></table><h3 id="启用方式-1" tabindex="-1"><a class="header-anchor" href="#启用方式-1"><span>启用方式</span></a></h3><p>Java 24 中，紧凑对象头是实验性功能，需要特定 JVM 参数启用，Java 25 成为正式功能，无需手动启动。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token parameter variable">-XX:+UnlockExperimentalVMOptions</span> <span class="token parameter variable">-XX:+UseCompactObjectHeaders</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1"><span>适用场景</span></a></h3><p>紧凑对象头尤其适用于以下场景：</p><ul><li><strong>大量小对象</strong>的应用（如微服务、DTO、缓存元素）。</li><li><strong>内存敏感型</strong>工作负载（希望降低内存占用和提高部署密度）。</li><li><strong>关注缓存效率和高吞吐量</strong>的应用。</li></ul><p>在决定是否启用时，需考虑：</p><ul><li><strong>应用程序特性</strong>：若应用严重依赖偏向锁，需评估其影响。</li><li><strong>GC 选择</strong>：目前该特性主要支持 G1 和 Parallel GC。对于 ZGC 的支持尚未完成。</li><li><strong>类加载数量</strong>：确保应用加载的类数量远低于 400 万的上限。</li></ul><h2 id="jep-472-准备限制-jni-的使用" tabindex="-1"><a class="header-anchor" href="#jep-472-准备限制-jni-的使用"><span>JEP 472: 准备限制 JNI 的使用</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 472: Prepare to Restrict the Use of JNI</p><p>Issue warnings about uses of the Java Native Interface (JNI) and adjust the Foreign Function &amp; Memory (FFM) API to issue warnings in a consistent manner. All such warnings aim to prepare developers for a future release that ensures integrity by default by uniformly restricting JNI and the FFM API. Application developers can avoid both current warnings and future restrictions by selectively enabling these interfaces where essential.</p></div><p>JEP 472（Prepare to Restrict the Use of JNI）是JDK 24中的一个重要提案，旨在<strong>增强Java平台的安全性</strong>，通过引入对Java本地接口（JNI）使用的限制和警告，为未来版本默认禁止通过JNI或FFM API与本地代码互操作做准备。</p><h3 id="核心目标-1" tabindex="-1"><a class="header-anchor" href="#核心目标-1"><span>核心目标</span></a></h3><p>JEP 472的主要目标包括：</p><ul><li>保持JNI地位：继续保持JNI作为与本地代码互操作的标准方式的地位。</li><li>准备生态系统：准备Java生态系统迎接未来的版本，默认不允许通过JNI或FFM API与本地代码互操作。自该版本起，应用程序开发者必须在启动时显式启用JNI和FFM API的使用。</li><li>统一使用方式：统一JNI和FFM API的使用方式，使库维护者可以在两者之间迁移而无需应用程序开发者更改任何命令行选项。</li></ul><h3 id="动机与背景" tabindex="-1"><a class="header-anchor" href="#动机与背景"><span>动机与背景</span></a></h3><p>JNI自JDK 1.1引入以来，一直是Java代码与本地代码（通常用C/C++编写）互操作的主要手段。但它也带来了显著的安全风险：</p><ul><li>未定义行为与崩溃：调用本地代码可能导致任意的未定义行为，包括JVM崩溃，且Java运行时无法阻止此类问题，也无法抛出可捕获的异常。</li><li>内存安全风险：本地代码和Java代码经常通过直接字节缓冲区交换数据，这些区域不受JVM垃圾收集器管理。本地代码可能生成由无效内存区域支持的字节缓冲区，在Java代码中使用会引发未定义行为。</li><li>绕过访问检查：本地代码可以使用JNI访问字段和调用方法，而不经过JVM的任何访问检查，甚至可以改变<code>final</code>字段的值，从而破坏其他Java代码的一致性。</li><li>不良GC行为：不正确使用某些JNI函数（如<code>GetPrimitiveArrayCritical</code>和<code>GetStringCritical</code>）可能导致不良的垃圾回收行为。</li></ul><p>JDK 22引入的外部函数与内存（FFM）API作为JNI的现代替代方案，虽然也面临类似风险，但其设计通过“受限方法”和要求开发者显式选择加入来缓解风险。JEP 472旨在使JNI遵循类似的安全范式，这是确保Java平台默认一致性（默认安全）的长期努力的一部分，其他相关举措包括移除<code>sun.misc.Unsafe</code>中的内存访问方法（JEP 471）和限制动态加载代理（JEP 451）。</p><h3 id="核心变化" tabindex="-1"><a class="header-anchor" href="#核心变化"><span>核心变化</span></a></h3><p>JEP 472的核心变化在于对JNI的“加载和链接本地库”操作施加本地访问限制（Native Access Restrictions），并与FFM API保持一致。</p><ul><li><p>受限操作：在JDK 24中，以下操作将默认触发警告（未来版本将抛出异常）：</p><ul><li>调用<code>System::loadLibrary</code>, <code>System::load</code>, <code>Runtime::loadLibrary</code>或<code>Runtime::load</code>。</li><li>声明<code>native</code>方法。</li></ul></li><li><p>启用本地访问：应用程序开发者必须显式启用本地访问以避免警告和未来的异常。这可以通过以下方式实现：</p><ul><li>命令行选项：<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token comment"># 为类路径上的所有代码启用</span></span>
<span class="line"><span class="token function">java</span> --enable-native-access<span class="token operator">=</span>ALL-UNNAMED <span class="token parameter variable">-jar</span> your_app.jar</span>
<span class="line"><span class="token comment"># 为模块路径上的特定模块启用</span></span>
<span class="line"><span class="token function">java</span> --enable-native-access<span class="token operator">=</span>MODULE1,MODULE2 <span class="token parameter variable">-jar</span> your_app.jar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>参数文件：在 <code>config-file</code> 中写入 <code>--enable-native-access=ALL-UNNAMED</code>，然后运行 <code>java @config-file -jar myapp.jar</code></li><li>环境变量传递：<code>export JDK_JAVA_OPTIONS=&quot;--enable-native-access=ALL-UNNAMED&quot;</code>，然后运行<code>java -jar myapp.jar</code></li><li>JAR清单属性：在可执行JAR的清单中添加<code>Enable-Native-Access: ALL-UNNAMED</code>。</li><li>其他方式：如通过<code>jlink</code>定制运行时镜像时添加选项，或使用<code>ModuleLayer.Controller::enableNativeAccess</code>方法（其本身是受限方法）。</li></ul></li><li><p>控制限制效果：新的命令行选项<code>--illegal-native-access</code>用于控制违反限制时的行为：</p><ul><li><code>warn</code>（JDK 24默认）：允许操作但发出警告（每个模块最多一次）。</li><li><code>deny</code>：抛出<code>IllegalCallerException</code>（未来版本的默认行为）。</li><li><code>allow</code>：允许操作继续（未来版本会移除）。</li></ul></li></ul><h3 id="未来计划" tabindex="-1"><a class="header-anchor" href="#未来计划"><span>未来计划</span></a></h3><p>JEP 472是分阶段实施的长期计划的一部分：</p><ul><li>JDK 24：默认行为是<code>--illegal-native-access=warn</code>，即发出警告。</li><li>未来JDK版本：默认行为将变为<code>--illegal-native-access=deny</code>，即抛出异常，最终实现默认一致性。</li></ul><h3 id="重要说明" tabindex="-1"><a class="header-anchor" href="#重要说明"><span>重要说明</span></a></h3><ul><li>不弃用JNI：JEP 472并非要弃用或移除JNI，也不是要限制本地代码本身的行为。所有本地JNI函数仍然可供本地代码使用。</li><li>影响范围：此限制主要影响加载本地库和链接native方法的Java代码。仅调用其他模块中声明的<code>native</code>方法的代码本身不需要启用本地访问。</li><li>FFM API对齐：JNI和FFM API在本地访问限制上保持一致，简化了库的迁移和应用程序的配置。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>JEP 472是Java迈向“默认安全” 的重要一步。它通过引入对JNI使用的限制和警告，促使开发者更显式地管理本地代码访问，从而提升应用程序和Java平台整体的安全性和完整性。</p><p>虽然这增加了些许配置成本，但为构建更安全可靠的Java生态系统奠定了基础。对于开发者来说，关键是检查现有代码并适时添加<code>--enable-native-access</code>标志。</p><h2 id="jep-475-g1-的-late-barrier-扩展" tabindex="-1"><a class="header-anchor" href="#jep-475-g1-的-late-barrier-扩展"><span>JEP 475: G1 的 Late Barrier 扩展</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 475: Late Barrier Expansion for G1</p><p>Simplify the implementation of the G1 garbage collector&#39;s barriers, which record information about application memory accesses, by shifting their expansion from early in the C2 JIT&#39;s compilation pipeline to later.</p></div><p>G1 垃圾收集器的后期屏障扩展旨在通过将屏障的扩展从 C2 编译管道的早期移到后期来简化 G1 屏障的实现。屏障记录有关应用程序内存访问的信息。目标包括减少使用 G1 收集器时 C2 编译的执行时间，使对 C2 缺乏深入了解的 HotSpot 开发人员能够理解 G1 屏障，并确保 C2 保留有关内存访问、安全点和屏障的相对顺序的不变量。第四个功能是保留 C2 生成的 JIT（即时）编译代码的质量（速度和大小）。</p><h2 id="jep-478-密钥派生函数-api-预览" tabindex="-1"><a class="header-anchor" href="#jep-478-密钥派生函数-api-预览"><span>JEP 478: 密钥派生函数 API（预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 478: Key Derivation Function API (Preview)</p><p>Introduce an API for Key Derivation Functions (KDFs), which are cryptographic algorithms for deriving additional keys from a secret key and other data. This is a preview API.</p></div><p>借助密钥派生函数 (KDF) API，将引入用于密钥派生函数的 API，这些函数是用于从密钥和其他数据派生其他密钥的加密算法。此提案的目标是允许安全提供商以 Java 代码或本机代码实现 KDF 算法。另一个目标是使应用程序能够使用 KDF 算法，例如基于 HMAC（哈希消息认证码）的提取和扩展密钥派生函数 ( RFC 5869 ) 和 Argon2 ( RFC 9106 )。</p><h2 id="jep-479-删除-windows-32-位-x86-端口" tabindex="-1"><a class="header-anchor" href="#jep-479-删除-windows-32-位-x86-端口"><span>JEP 479: 删除 Windows 32 位 x86 端口</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 479: Remove the Windows 32-bit x86 Port</p><p>Remove the source code and build support for the Windows 32-bit x86 port. This port was deprecated for removal in JDK 21 with the express intent to remove it in a future release.</p></div><p>移除针对 Windows 32 位 x86 端口的源代码和构建支持。该端口在 JDK 21 中已被标记为“弃用以待移除”，并明确表达了在未来的版本中将其移除的意图。</p><h2 id="jep-483-提前类加载和链接" tabindex="-1"><a class="header-anchor" href="#jep-483-提前类加载和链接"><span>JEP 483: 提前类加载和链接</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 483: Ahead-of-Time Class Loading &amp; Linking</p><p>Improve startup time by making the classes of an application instantly available, in a loaded and linked state, when the HotSpot Java Virtual Machine starts. Achieve this by monitoring the application during one run and storing the loaded and linked forms of all classes in a cache for use in subsequent runs. Lay a foundation for future improvements to both startup and warmup time.</p></div><p>提前类加载和链接旨在缩短启动时间，方法是在 HotSpot Java 虚拟机启动时，使应用程序的类立即处于加载和链接状态。这将通过在一次运行期间监视应用程序并将所有类的加载和链接形式存储在缓存中以供后续运行使用来实现。</p><h2 id="jep-484-类文件-api" tabindex="-1"><a class="header-anchor" href="#jep-484-类文件-api"><span>JEP 484: 类文件 API</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 484: Class-File API</p><p>Provide a standard API for parsing, generating, and transforming Java class files.</p></div><p>之前在 JDK 22 和 JDK 23 中预览过的类文件 API 将在 JDK 24 中最终确定，但会略有改动。此 API 提供了一个用于解析、生成和转换 Java 类文件的标准 API。其目的是提供一个用于处理类文件的 API，该 API 跟踪 Java 虚拟机规范定义的类文件格式。第二个目标是使 JDK 组件能够迁移到标准 API，并最终删除 JDK 内部的第三方 ASM 库副本。自第二个预览版以来的更改包括重命名枚举值、删除某些字段、添加方法和方法重载、重命名方法以及删除被认为不必要的接口和方法。</p><h2 id="jep-485-流收集器" tabindex="-1"><a class="header-anchor" href="#jep-485-流收集器"><span>JEP 485: 流收集器</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 485: Stream Gatherers</p><p>Enhance the Stream API to support custom intermediate operations. This will allow stream pipelines to transform data in ways that are not easily achievable with the existing built-in intermediate operations.</p></div><p>流收集器（Stream Gatherers）能为Stream API轻松添加自定义的中间操作，实现更复杂的数据转换。</p><h2 id="jep-486-永久禁用安全管理器" tabindex="-1"><a class="header-anchor" href="#jep-486-永久禁用安全管理器"><span>JEP 486: 永久禁用安全管理器</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 486: Permanently Disable the Security Manager</p><p>The Security Manager has not been the primary means of securing client-side Java code for many years, it has rarely been used to secure server-side code, and it is costly to maintain. We therefore deprecated it for removal in Java 17 via JEP 411 (2021). As the next step toward removing the Security Manager, we will revise the Java Platform specification so that developers cannot enable it and other Platform classes do not refer to it. This change will have no impact on the vast majority of applications, libraries, and tools. We will remove the Security Manager API in a future release.</p></div><p>永久禁用安全管理器需要修改 Java 平台规范，以便开发人员无法启用安全管理器，而其他平台类则不会引用它。提案指出，多年来，安全管理器一直不是保护客户端 Java 代码的主要手段，很少用于保护服务器端代码，而且维护成本高昂。安全管理器已在 Java 17 中被弃用并被删除。</p><h2 id="jep-487-范围值-第四个预览版" tabindex="-1"><a class="header-anchor" href="#jep-487-范围值-第四个预览版"><span>JEP 487: 范围值（第四个预览版）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 487: Scoped Values (Fourth Preview)</p><p>Introduce scoped values, which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads (JEP 444) and structured concurrency (JEP 480). This is a preview API.</p></div><p>范围值使方法能够与线程内的调用方和子线程共享不可变数据。范围值比本地线程变量更容易推理。它们还具有较低的空间和时间成本，特别是与虚拟线程和结构化并发一起使用时。范围值 API 是在 JDK 20 中提出的孵化版，在 JDK 21 中提出的预览版，并针对 JDK 22 和 JDK 23 进行了改进和完善。范围值将在 JDK 24 中预览。</p><h2 id="jep-488-模式、instanceof-和-switch中的原始类型-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-488-模式、instanceof-和-switch中的原始类型-第二次预览"><span>JEP 488: 模式、instanceof 和 switch中的原始类型（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 488: Primitive Types in Patterns, instanceof, and switch (Second Preview)</p><p>Enhance pattern matching by allowing primitive types in all pattern contexts, and extend instanceof and switch to work with all primitive types. This is a preview language feature.</p></div><p>JEP 488 在模式匹配的上下文中允许<strong>原始类型模式与对应包装类型之间的宽松转换</strong>，并支持<strong>对记录组件的类型宽松匹配</strong>。核心贡献是：</p><ul><li><p>原始类型模式与对应包装类型之间的宽松转换</p><ul><li>增强 instanceof 和 switch 构造以支持原始类型模式作为顶级模式：允许在模式匹配中直接使用原始类型（如 <code>int p</code>）来匹配包装类（如 <code>Integer</code>）的对象。</li><li>增强记录模式以支持类型转换：允许在记录模式中使用原始类型来匹配包装类型的记录组件值，无需严格匹配包装类型。</li></ul></li><li><p>对记录组件的类型宽松匹配：在记录模式中使用原始类型来匹配记录的组件值时，无需严格匹配原始类型。这一机制支持在解构记录时自动完成原始类型的加宽转换和有条件的安全缩窄转换，显著提升了代码的简洁性与灵活性。</p></li><li><p>安全性</p><ul><li>妥善处理 null 值，原始类型模式不会匹配 null，从而避免了潜在的 NullPointerException。</li><li>对于记录模式中可能造成信息丢失的缩窄转换（如 double → int），模式匹配会在运行时自动检查值的兼容性，仅在不丢失信息时完成匹配，否则返回 false，保障匹配过程的安全性与可靠性。</li></ul></li><li><p>语法与一致性更新：引入了相应的支配性检查规则，在同一个 switch 块中，原始类型模式（如 int i）和其对应的包装类型模式（如 Integer i）不能同时存在，因为它们会互相导致对方不可到达，无论顺序如何都会编译报错。记录模式也遵循相同的类型转换原则，进一步强化了模式匹配整体的语言一致性和表达力。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>模式 (Pattern)是一个通用概念，指的是在条件判断中同时进行类型检查和变量绑定的操作。例如：obj instanceof String s 就是一个类型模式，它同时检查 obj 是否是 String 类型，如果是，则将其绑定到变量 s。</p><p>instanceof 运算符是应用类型模式的第一个地方。从 Java 16 开始，instanceof 后面可以直接跟一个类型模式和变量名。</p><p>switch 表达式/语句是应用多种模式（包括类型模式、常量模式等）的更强大场所。在 Java 17 和 21 中，switch 的能力被大幅增强，case 标签可以支持模式。</p><p>所以三者关系是：模式匹配是一个范式；instanceof 和 switch 是应用该范式的语法工具。</p><p>因此，对JEP 488最准确的理解是：为模式、instanceof 和 switch 添加对原始类型的支持。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>自动加宽转换： 使用一个 “较宽”的类型模式 (double) 去匹配一个 “较窄”的组件类型 (int) 的值。编译器允许这种操作，并自动完成安全的值转换。</p><p>有条件的安全缩窄转换： 缩窄转换是一种可能丢失信息的转换（例如，将 double 3.14 转换为 int 3 会丢失小数部分），因此不是无条件进行的。</p><ul><li>JVM 会先检查这个 double 值是否能完全精确地转换为一个 int 值（即没有小数部分，且在 int 的取值范围内）</li><li>如果检查通过：模式匹配成功，变量被赋值</li><li>如果检查不通过（值太大或有小数）：模式匹配直接返回 false，不会赋值，也不会抛出异常</li></ul><p>注意：</p><ul><li>“自动加宽转换”和“有条件的安全缩窄转换”要求初始类型和目标类型都是原始类型。</li></ul></div><p><a class="route-link" href="/java/new-features/primitive-types-in-patterns-instanceof-and-switch.html">模式、instanceof 和 switch中的原始类型</a></p><h2 id="jep-489-向量-api-第九个孵化器" tabindex="-1"><a class="header-anchor" href="#jep-489-向量-api-第九个孵化器"><span>JEP 489: 向量 API（第九个孵化器）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 489: Vector API (Ninth Incubator)</p><p>Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations.</p></div><p>允许表达在运行时编译为最优向量指令的计算，用于高性能数值计算和 AI 推理等领域。</p><h2 id="jep-490-zgc-删除非分代模式" tabindex="-1"><a class="header-anchor" href="#jep-490-zgc-删除非分代模式"><span>JEP 490: ZGC：删除非分代模式</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 490: ZGC: Remove the Non-Generational Mode</p><p>Remove the non-generational mode of the Z Garbage Collector (ZGC), keeping the generational mode as the default for ZGC.</p></div><p>删除 Z 垃圾收集器 (ZGC) 的非分代模式，旨在降低支持两种不同模式的维护成本。该提案指出，维护非分代 ZGC 会减慢新功能的开发速度，而对于大多数用例而言，分代 ZGC 应该是比非分代 ZGC 更好的解决方案。后者最终应该被前者取代，以降低长期维护成本。该计划要求通过淘汰 ZGenerational 选项并删除非分代 ZGC 代码及其测试来删除非分代模式。非分代模式将在未来的版本中过期，届时它将不会被 HotSpot JVM 识别，从而拒绝启动。</p><h2 id="jep-491-无需固定即可同步虚拟线程" tabindex="-1"><a class="header-anchor" href="#jep-491-无需固定即可同步虚拟线程"><span>JEP 491: 无需固定即可同步虚拟线程</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 491: Synchronize Virtual Threads without Pinning</p><p>Improve the scalability of Java code that uses synchronized methods and statements by arranging for virtual threads that block in such constructs to release their underlying platform threads for use by other virtual threads. This will eliminate nearly all cases of virtual threads being pinned to platform threads, which severely restricts the number of virtual threads available to handle an application&#39;s workload.</p></div><p>优化了虚拟线程在同步操作（如 <code>synchronized</code>）时的性能，减少了“线程固定”（pinning）问题，从而提升了虚拟线程的吞吐量和可扩展性。</p><h2 id="jep-492-灵活的构造函数体-第三次预览" tabindex="-1"><a class="header-anchor" href="#jep-492-灵活的构造函数体-第三次预览"><span>JEP 492: 灵活的构造函数体（第三次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 492: Flexible Constructor Bodies (Third Preview)</p><p>In constructors in the Java programming language, allow statements to appear before an explicit constructor invocation, i.e., super(..) or this(..). The statements cannot reference the instance under construction, but they can initialize its fields. Initializing fields before invoking another constructor makes a class more reliable when methods are overridden. This is a preview language feature.</p></div><p>在 Java 编程语言的构造函数中，允许在显式构造函数调用（即 super(..) 或 this(..)）之前出现语句。这些语句不能引用正在构建的实例，但可以初始化其字段。在调用另一个构造函数之前初始化字段，可以在方法被重写时提高类的可靠性。这是一个预览语言特性。</p><h2 id="jep-493-无需-jmod-即可链接运行时图像" tabindex="-1"><a class="header-anchor" href="#jep-493-无需-jmod-即可链接运行时图像"><span>JEP 493: 无需 JMOD 即可链接运行时图像</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 493: Linking Run-Time Images without JMODs</p><p>Reduce the size of the JDK by approximately 25% by enabling the jlink tool to create custom run-time images without using the JDK&#39;s JMOD files. This feature must be enabled when the JDK is built; it will not be enabled by default, and some JDK vendors may choose not to enable it.</p></div><p>通过链接不使用 JMOD 的运行时映像，计划通过启用 jlink 工具来创建不使用 JDK JMOD（模块化 JAR）文件的自定义运行时映像，将 JDK 的大小减少约 25%。在构建 JDK 时必须启用此功能（默认情况下不会启用），某些 JDK 供应商可能选择不启用它。目标包括允许用户从模块链接运行时映像，而不管这些模块是独立的 JMOD 文件、模块化 JAR 文件还是先前链接的运行时映像的一部分。提出该提案的动机是，在云环境中，文件系统上安装的 JDK 的大小非常重要，因为包含已安装 JDK 的容器映像会通过网络自动且频繁地从容器注册表复制。减小 JDK 的大小将提高这些操作的效率。</p><h2 id="jep-494-模块导入声明-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-494-模块导入声明-第二次预览"><span>JEP 494: 模块导入声明（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 494: Module Import Declarations (Second Preview)</p><p>Enhance the Java programming language with the ability to succinctly import all of the packages exported by a module. This simplifies the reuse of modular libraries, but does not require the importing code to be in a module itself. This is a preview language feature.</p></div><p>增强 Java 编程语言，使其能够简洁地导入某个模块所导出的所有包。这简化了模块化库的重用，且调用方代码自身不必是模块化的。这是一项预览语言特性。</p><p><strong>使用新特性导入整个模块</strong> 假设有一个名为 com.example.utils 的模块，其 module-info.java 文件导出了了一些包：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// module-info.java</span></span>
<span class="line"><span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在另一个非模块化的应用程序（即没有 module-info.java）中，现在可以使用一种新的导入语句来一次性导入 com.example.utils 模块导出的所有包。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// 使用 &#39;import module&#39; 关键字一次性导入整个模块的所有导出包</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 现在可以直接使用被导入模块中所有导出包下的类，而无需逐个导入</span></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.math 包</span></span>
<span class="line">    <span class="token class-name">Calculator</span> calc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">double</span> result <span class="token operator">=</span> calc<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.logging 包</span></span>
<span class="line">    <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Result is: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与之前方式的对比</strong></p><ul><li>方式一（传统非模块化项目）： 必须逐个导入所需的每个类或包。<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">Calculator</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// ... 还需要导入其他要用的类 ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>方式二（模块化项目）： 即使只想用一两个类，也必须在自己的 module-info.java 中声明对整个模块的依赖。<div class="vp-code-tabs"><div class="vp-code-tabs-nav" role="tablist"><button type="button" class="vp-code-tab-nav active" role="tab" aria-controls="codetab-834-0" aria-selected="true">module-info.java</button><button type="button" class="vp-code-tab-nav" role="tab" aria-controls="codetab-834-1" aria-selected="false">MyApp.java</button></div><!--[--><div class="vp-code-tab active" id="codetab-834-0" role="tabpanel" aria-expanded="true"><div class="vp-code-tab-title">module-info.java</div><!--[--><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">module</span> <span class="token namespace">my<span class="token punctuation">.</span>app</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">requires</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// ... 其他依赖 ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!--]--></div><div class="vp-code-tab" id="codetab-834-1" role="tabpanel" aria-expanded="false"><div class="vp-code-tab-title">MyApp.java</div><!--[--><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token punctuation">.</span>math<span class="token punctuation">.</span>Calculator<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><!--]--></div><!--]--></div></li><li>使用新特性后的方式（简洁且无需模块化）： <ul><li>无需自身的 module-info.java。</li><li>一行语句 import module com.example.utils.*; 即可获得该模块所有导出包的访问权，无需再写多个 import 语句。</li></ul></li></ul><p>之前在 JDK 23 中预览过，本次改动点：</p><ul><li>解除任何模块都不能声明对 java.base 模块的传递依赖的限制</li><li>修改 java.se 模块的声明</li><li>允许 type-import-on-demand 声明遮蔽模块导入声明</li></ul><h2 id="jep-495-简单源文件和实例主要方法-第四次预览" tabindex="-1"><a class="header-anchor" href="#jep-495-简单源文件和实例主要方法-第四次预览"><span>JEP 495: 简单源文件和实例主要方法（第四次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)</p><p>Evolve the Java programming language so that beginners can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of the language, beginners can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. Experienced developers can likewise enjoy writing small programs succinctly, without the need for constructs intended for programming in the large. This is a preview language feature.</p></div><p>发展 Java 编程语言，使初学者无需了解专为大型程序设计的语言功能，即可编写自己的第一个程序。初学者无需使用某种独立的语言变体，即可为单类程序编写简化的声明，然后随着技能的增长无缝扩展他们的程序以使用更高级的功能。经验丰富的开发者同样可以简洁地编写小型程序，而不必使用那些为大规模编程设计的结构。</p><p>简单说就是省略显式类声明和 public static 修饰符，简化输出语句，来简化入门代码和脚本开发。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Java 23!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式调用 System.out.println</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改动点：</p><ul><li>将<strong>隐式声明的类和实例主方法</strong>重命名为<strong>简单源文件和实例主要方法</strong></li></ul><h2 id="jep-496-基于抗量子模块格的密钥封装机制-jep-497-基于模块格的抗量子数字签名算法" tabindex="-1"><a class="header-anchor" href="#jep-496-基于抗量子模块格的密钥封装机制-jep-497-基于模块格的抗量子数字签名算法"><span>JEP 496: 基于抗量子模块格的密钥封装机制 &amp; JEP 497: 基于模块格的抗量子数字签名算法</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 496: Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism</p><p>Enhance the security of Java applications by providing an implementation of the quantum-resistant Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). Key encapsulation mechanisms (KEMs) are used to secure symmetric keys over insecure communication channels using public key cryptography. ML-KEM is designed to be secure against future quantum computing attacks. It has been standardized by the United States National Institute of Standards and Technology (NIST) in FIPS 203.</p></div><p>为通过抗量子性提高 Java 安全性而提出的两个功能包括抗量子的基于模块格的密钥封装机制(ML-KEM) 和抗量子的基于模块格的数字签名算法(ML-DSA)。ML-DSA 将通过提供抗量子的数字签名来检测对数据的未经授权的修改并验证签名者的身份，从而防止未来的量子计算攻击。密钥封装机制 (KEM) 用于使用公钥加密技术通过不安全的通信通道保护对称密钥。这两个功能都旨在防止未来的量子计算攻击。下一步将是引入对这些 API 和密钥派生函数 API 的 TLS（传输层安全性）支持。</p><h2 id="jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告" tabindex="-1"><a class="header-anchor" href="#jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告"><span>JEP 498: 在 sun.misc.Unsafe 中使用内存访问方法时发出警告</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 498: Warn upon Use of Memory-Access Methods in sun.misc.Unsafe</p><p>Issue a warning at run time on the first occasion that any memory-access method in sun.misc.Unsafe is invoked. All of these unsupported methods were terminally deprecated in JDK 23. They have been superseded by standard APIs, namely the VarHandle API (JEP 193, JDK 9) and the Foreign Function &amp; Memory API (JEP 454, JDK 22). We strongly encourage library developers to migrate from sun.misc.Unsafe to supported replacements, so that applications can migrate smoothly to modern JDK releases.</p></div><p>Java 会在运行时首次调用 sun.misc.Unsafe 中的任何内存访问方法时发出警告。所有这些不受支持的方法在 JDK 23 中都已弃用，并已被标准 API 取代。创建 sun.misc.Unsafe 类是为了为 Java 类提供一种执行低级操作的机制。它的大多数方法用于访问内存，无论是在 JVM 的垃圾收集堆中还是在堆外内存中，这些内存不受 JVM 控制。正如类名所示，这些内存访问方法是不安全的。</p><h2 id="jep-499-结构化并发-第四次预览" tabindex="-1"><a class="header-anchor" href="#jep-499-结构化并发-第四次预览"><span>JEP 499: 结构化并发（第四次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 499: Structured Concurrency (Fourth Preview)</p><p>Simplify concurrent programming by introducing an API for structured concurrency. Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API.</p></div><p>通过引入结构化并发 API 来简化并发编程。结构化并发将不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。这是一个预览 API。</p><h2 id="jep-501-弃用-32-位-x86-端口并将其删除" tabindex="-1"><a class="header-anchor" href="#jep-501-弃用-32-位-x86-端口并将其删除"><span>JEP 501: 弃用 32 位 x86 端口并将其删除</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 501: Deprecate the 32-bit x86 Port for Removal</p><p>Deprecate the 32-bit x86 port, with the intent to remove it in a future release. This will thereby deprecate the Linux 32-bit x86 port, which is the only 32-bit x86 port remaining in the JDK. It will also, effectively, deprecate any remaining downstream 32-bit x86 ports. After the 32-bit x86 port is removed, the architecture-agnostic Zero port will be the only way to run Java programs on 32-bit x86 processors.</p></div><p>弃用 32 位 x86 端口并删除，这是在弃用 Windows 32 位 x86 端口的提议之后做出的，这将弃用 Linux 32 位 x86 端口，这是 JDK 中剩余的唯一 32 位 x86 端口。它还将有效弃用任何剩余的下游 32 位 x86 端口。在删除 32 位 x86 端口后，与架构无关的零端口将成为在 32 位 x86 处理器上运行 Java 程序的唯一方法。在 JDK 24 中弃用 32 位 x86 端口将允许在 JDK 25 中将其删除。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新：: </span><time class="meta-item-info" datetime="2025-09-15T06:59:55.000Z" data-allow-mismatch>2025/9/15 06:59</time></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 3036190149@qq.com">zhaomy</span><!----><!--]--><!--]--></span></div></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/java/new-features/java-25-features.html" aria-label="Java 25 新特性"><!--[--><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span class="external-link">Java 25 新特性</span></div><!--]--></a><!----></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-REDOwCgz.js" defer></script>
  </body>
</html>
