# Shenandoah 垃圾回收器详解

## 概述

Shenandoah是一个旨在提供极低延迟的垃圾回收器，特别适合对响应时间要求极高的应用程序。它由Red Hat开发，在JDK 11中作为实验性功能首次引入，但需特定构建版本，JDK 12中并入OpenJDK代码库，但Oracle官方JDK 12不包含，JDK 15成为正式版本，并在后续版本中不断改进。Shenandoah的核心目标是实现亚毫秒级的垃圾回收停顿时间，同时保持良好的吞吐量。

## 核心原理

### 1. 并发标记-压缩算法

Shenandoah的核心创新是实现了完全并发的标记-压缩算法，这意味着垃圾回收的大部分工作（包括标记和压缩阶段）都可以与应用程序并发执行，只有极少数操作需要短暂停顿应用程序。

### 2. 基于Region的内存布局

与G1类似，Shenandoah也采用基于Region的内存布局，将堆内存划分为多个大小相等的Region。Region的大小可以通过参数 `-XX:ShenandoahHeapRegionSize`设置。

### 3. 读屏障（Read Barrier）技术

Shenandoah使用读屏障技术来处理并发回收过程中的对象引用问题。当应用程序读取对象引用时，读屏障会检查该引用是否指向了正在被移动的对象，如果是，则会将引用重定向到对象的新位置。

### 4.  Brooks指针

Shenandoah使用Brooks指针来支持对象的并发移动。每个对象头部都包含一个Brooks指针，指向对象的当前位置。当对象被移动时，Brooks指针会被更新为新位置，而旧位置会保留一个转发指针，指向新位置。

## 垃圾回收过程

### 1. 初始标记（Initial Mark）

标记GC Roots直接引用的对象，需要短暂停顿应用程序。

### 2. 并发标记（Concurrent Mark）

与应用程序并发执行，遍历对象图并标记存活对象。

### 3. 最终标记（Final Mark）

处理标记过程中的最后细节，需要短暂停顿应用程序。

### 4. 并发清理（Concurrent Cleanup）

回收完全为空的Region，与应用程序并发执行。

### 5. 并发压缩（Concurrent Compaction）

移动存活对象并压缩内存空间，与应用程序并发执行。这是Shenandoah的核心阶段，通过Brooks指针和读屏障技术实现完全并发的对象移动。

### 6. 并发重置（Concurrent Reset）

重置内部数据结构，为下一次垃圾回收做准备，与应用程序并发执行。

## 分代Shenandoah（实验性）

JDK 24中引入的JEP 404提供了实验性的分代模式，将分代概念引入Shenandoah GC。通过区分新生代和老年代，分代Shenandoah实现了显著的性能突破：

### 核心优化点

- **新生代专用回收策略**：采用复制算法快速回收短生命周期对象，减少老年代扫描频率
- **卡表（Card Table）优化**：精确记录老年代到新生代的跨代引用，旨在显著降低停顿时间
- **并行标记增强**：在并发标记阶段优先处理新生代区域，在特定场景下平均暂停时间可低至毫秒级

## 关键参数调优

| 参数                             | 描述                         | 默认值   |
| -------------------------------- | ---------------------------- | -------- |
| `-XX:+UseShenandoahGC`         | 启用Shenandoah垃圾回收器     | 否       |
| `-XX:ShenandoahHeapRegionSize` | 每个Region的大小             | 自动计算 |
| `-XX:ShenandoahGCHeuristics`   | GC策略选择                   | adaptive |
| `-XX:ShenandoahMinFreeRatio`   | 最小空闲内存比例             | 10%      |
| `-XX:ShenandoahMaxFreeRatio`   | 最大空闲内存比例             | 50%      |
| `-XX:+ShenandoahGenerational`  | 启用分代Shenandoah（实验性） | 否       |

## 适用场景

Shenandoah特别适合以下场景：

- 对延迟要求极高的应用程序（如金融交易系统、实时游戏等）
- 堆内存较大（通常大于8GB）
- 希望减少或消除垃圾回收导致的应用程序停顿
- 多核CPU环境（Shenandoah的并发特性可以充分利用多核CPU）

## 优势与不足

### 优势

- 极低的停顿时间：通过并发标记-压缩算法，实现毫秒级的垃圾回收停顿
- 高效处理大堆内存：在大堆内存（如64GB或更大）情况下仍能保持良好性能
- 不需要完全GC：Shenandoah可以通过并发压缩逐步清理内存，减少完全GC的发生
- 适应高吞吐量需求：在保证低延迟的同时，保持良好的吞吐量

### 不足

- 实验性特性：部分功能（如分代Shenandoah）仍处于实验阶段
- 内存占用较大：需要额外内存来支持并发回收和对象移动
- CPU开销较高：并发回收过程会占用部分CPU资源
- 兼容性问题：某些第三方库可能与Shenandoah的读屏障技术不兼容

## 与其他垃圾回收器的比较

| 特性         | G1           | Shenandoah | ZGC           |
| ------------ | ------------ | ---------- | ------------- |
| 最大停顿时间  | 毫秒级     | 亚毫秒级(目标) | 亚毫秒级      |
| 并发压缩     | 部分支持     | 支持        | 支持          |
| 成熟度      | JDK9默认    | JDK15正式    | JDK15正式  |
| 分代       | 支持       | JDK24实验性支持 | JDK21实验性支持<br>JDK23分代模式为ZGC默认模式<br>JDK24移除非ZGC分代模式 |
| 内存占用     | 中           | 较高       | 高            |
| 适用堆大小   | 中（4-64GB）  | 大（>8GB） | 极大（>64GB） |

> Shenandoah在中小堆上也能发挥其低延迟优势，选择与否更取决于对延迟而非堆大小的要求。
