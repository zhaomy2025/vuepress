# G1 垃圾回收器详解

## 概述

G1（Garbage-First）是一款面向服务端应用的垃圾回收器，它采用了独特的区域化分代（Region-based Generational） 内存布局和停顿预测模型，旨在兼顾高吞吐量与可预测的低延迟。

## 核心原理

### 1. 基于区域的内存布局
G1将堆内存划分为多个大小相等的独立区域（Region），每个Region的大小可以通过参数`-XX:G1HeapRegionSize`设置，取值范围为1MB到32MB，且必须是2的幂次方。Region可以是以下类型：
- 新生代（Eden）Region
- 存活区（Survivor）Region
- 老年代（Old）Region
- 大对象（Humongous）Region：用于存储超过单个Region容量一半的对象

### 2. 停顿预测模型
G1的核心特性是基于停顿时间的垃圾回收策略。它会维护一个回收成本效益模型，记录每个Region的回收效率（回收的内存量/回收所需时间）。然后根据用户设定的最大停顿时间目标（`-XX:MaxGCPauseMillis`，默认200ms），动态选择一组回收效益最高的Region进行回收。

### 3. 并行与并发操作
G1结合了并行和并发垃圾回收技术：
- 年轻代回收（Young GC）：多线程并行执行，会导致应用程序停顿
- 混合回收（Mixed GC）：部分工作并行执行，部分工作与应用程序并发执行
- 标记阶段：大部分工作与应用程序并发执行

## 垃圾回收过程

### 1. 年轻代回收（Young GC）
当Eden区满时触发，G1会将Eden区和Survivor区中的存活对象复制到新的Survivor区或老年代。此过程完全并行执行，会导致应用程序停顿。

### 2. 并发标记（Concurrent Marking）
当老年代占用率达到一定阈值（可通过`-XX:InitiatingHeapOccupancyPercent`设置，默认45%）时触发，包括以下阶段：
- 初始标记（Initial Mark）：标记GC Roots直接引用的对象，需要短暂停顿应用程序
- 并发标记（Concurrent Mark）：与应用程序并发执行，遍历对象图并标记存活对象
- 重新标记（Remark）：修正并发标记期间因应用程序执行而产生的标记变化，需要短暂停顿
- 清理（Cleanup）：回收完全为空的Region，为混合回收做准备

### 3. 混合回收（Mixed GC）
在并发标记完成后触发，G1会选择一组回收效益最高的老年代Region和所有新生代Region进行回收。混合回收的目标是在用户指定的停顿时间内尽可能多地回收内存。

## 关键参数调优

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `-XX:+UseG1GC` | 启用G1垃圾回收器 | 否 |
| `-XX:MaxGCPauseMillis` | 最大GC停顿时间目标 | 200ms |
| `-XX:G1HeapRegionSize` | 每个Region的大小 | 自动计算 |
| `-XX:InitiatingHeapOccupancyPercent` | 触发并发标记的堆占用率阈值 | 45% |
| `-XX:G1NewSizePercent` | 新生代最小占比 | 5% |
| `-XX:G1MaxNewSizePercent` | 新生代最大占比 | 60% |
| `-XX:G1MixedGCLiveThresholdPercent` | 混合回收时Region中存活对象的最小占比 | 85% |
| `-XX:G1MixedGCCountTarget` | 混合回收的目标次数 | 8 |

## 适用场景
G1特别适合以下场景：
- 堆内存较大（通常大于4GB）
- 对垃圾回收停顿时间有严格要求
- 内存分配速率变化较大
- 希望减少垃圾回收对应用程序性能的影响

## 优势与不足

### 优势
- 可预测的停顿时间：通过停顿预测模型和Region选择策略，以用户设定的停顿时间为目标进行回收
- 高效处理大对象：通过Humongous Region专门存储大对象
- 尽量避免完全GC：G1可以通过混合回收逐步清理老年代，减少完全GC的发生
- 内存布局灵活：基于Region的内存布局，能够更好地适应不同的内存分配模式

### 不足
- 内存占用较大：G1需要维护Region的元数据信息，内存占用通常比其他垃圾回收器高
- 并发开销：并发标记阶段会占用部分CPU资源，可能影响应用程序性能
- 复杂的调优参数：G1有许多调优参数，需要深入了解才能充分发挥其性能

## JEP 475：G1的Late Barrier扩展
JDK 24中引入的JEP 475对G1的屏障实现进行了优化，将屏障的扩展从C2编译管道的早期移到后期，以简化G1屏障的实现。这一优化旨在：
- 减少使用G1收集器时C2编译的执行时间
- 使对C2缺乏深入了解的HotSpot开发人员能够理解G1屏障
- 确保C2保留有关内存访问、安全点和屏障的相对顺序的不变量
- 保留C2生成的JIT编译代码的质量（速度和大小）