# ZGC 垃圾回收器详解

## 概述

ZGC（Z Garbage Collector）是一个旨在提供极低延迟的垃圾回收器，特别适合内存占用极大的应用程序。它由Oracle开发，于JDK 11中首次引入，并在后续版本中不断改进。ZGC的核心目标是实现亚毫秒级的垃圾回收停顿时间，同时支持TB级别的堆内存。

## 核心原理

### 1. 基于Region的内存布局

与G1和Shenandoah类似，ZGC也采用基于Region的内存布局，将堆内存划分为多个大小不等的Region。Region的大小可以是2MB、32MB或16GB，具体取决于堆内存的大小。这种灵活的Region大小设计使得ZGC能够高效处理各种大小的对象。

### 2. 着色指针（Colored Pointers）技术

ZGC的核心创新是使用着色指针技术。它在对象指针中预留了几位用于存储额外信息，如对象的标记状态和年龄信息。通过着色指针，ZGC可以在不暂停应用程序的情况下进行对象标记和移动。

### 3. 读屏障（Read Barrier）技术

ZGC使用读屏障技术来处理并发回收过程中的对象引用问题。当应用程序读取对象引用时，读屏障会检查该引用是否指向了正在被移动的对象，如果是，则会将引用重定向到对象的新位置。

### 4. 并发标记-压缩算法

ZGC实现了完全并发的标记-压缩算法，这意味着垃圾回收的大部分工作（包括标记和压缩阶段）都可以与应用程序并发执行，只有极少数操作需要短暂停顿应用程序。

## 垃圾回收过程

### 1. 初始标记（Initial Mark）

标记GC Roots直接引用的对象，需要短暂停顿应用程序。

### 2. 并发标记（Concurrent Mark）

与应用程序并发执行，遍历对象图并标记存活对象。

### 3. 重新标记（Remark）

处理标记过程中的最后细节，需要短暂停顿应用程序。

### 4. 并发清理（Concurrent Cleanup）

回收完全为空的Region，与应用程序并发执行。

### 5. 并发压缩（Concurrent Compaction）

移动存活对象并压缩内存空间，与应用程序并发执行。这是ZGC的核心阶段，通过着色指针和读屏障技术实现完全并发的对象移动。

### 6. 并发重置（Concurrent Reset）

重置内部数据结构，为下一次垃圾回收做准备，与应用程序并发执行。

## 分代ZGC（实验性）

JDK 21中引入的JEP 439提供了实验性的分代模式，将分代概念引入ZGC。通过区分新生代和老年代，分代ZGC实现了显著的性能突破：

### 核心优化点

- **新生代专用回收策略**：采用复制算法快速回收短生命周期对象，减少老年代扫描频率
- **记忆集（Remembered Set）优化**：精确记录老年代到新生代的跨代引用，降低GC停顿时间
- **并行标记增强**：在并发标记阶段优先处理新生代区域，提高回收效率

### 性能提升

实测表明，在多核心服务器上，分代ZGC相比原版在处理短生命周期对象占比较高的工作负载时，吞吐量提升可达20-30%，同时保持亚毫秒级的最大暂停时间。

## 关键参数调优

| 参数                         | 描述                   | 默认值      |
| ---------------------------- | ---------------------- | ----------- |
| `-XX:+UseZGC`              | 启用ZGC垃圾回收器      | 否          |
| `-XX:ZHeapRegionSize`      | 每个Region的大小       | 自动计算    |
| `-XX:ZCollectionInterval`  | GC周期间隔时间（毫秒） | 0（自适应） |
| `-XX:ZPauseTimeGoal`       | 暂停时间目标（毫秒）   | 1           |
| `-XX:+ZGenerational`       | 启用分代ZGC（实验性）  | 否          |
| `-XX:ZYoungGenerationSize` | 新生代大小             | 自动计算    |

## 适用场景

ZGC特别适合以下场景：

- 对延迟要求极高的应用程序（如金融交易系统、实时数据分析等）
- 堆内存极大（通常大于64GB，甚至TB级）
- 希望减少或消除垃圾回收导致的应用程序停顿
- 多核CPU环境（ZGC的并发特性可以充分利用多核CPU）

## 优势与不足

### 优势

- 极低的停顿时间：通过并发标记-压缩算法和着色指针技术，实现亚毫秒级的垃圾回收停顿
- 支持极大堆内存：在TB级堆内存情况下仍能保持良好性能
- 不需要完全GC：ZGC可以通过并发压缩逐步清理内存，减少完全GC的发生
- 自适应调节：能够根据应用程序的行为自动调整垃圾回收策略

### 不足

- 实验性特性：部分功能（如分代ZGC）仍处于实验阶段
- 内存占用较大：需要额外内存来支持并发回收和对象移动
- CPU开销较高：并发回收过程会占用部分CPU资源
- 兼容性问题：某些第三方库可能与ZGC的读屏障技术不兼容

## 与其他垃圾回收器的比较

| 特性         | G1           | Shenandoah | ZGC           |
| ------------ | ------------ | ---------- | ------------- |
| 最大停顿时间  | 毫秒级     | 亚毫秒级(目标) | 亚毫秒级      |
| 并发压缩     | 部分支持     | 支持        | 支持          |
| 成熟度      | JDK9默认    | JDK15正式    | JDK15正式  |
| 分代       | 支持       | JDK24实验性支持 | JDK21实验性支持、JDK23默认、JDK24移除非分代模式 |
| 内存占用     | 中           | 较高       | 高            |
| 适用堆大小   | 中（4-64GB） | 大（>8GB） | 极大（>64GB） |