import{_ as s,c as u,a as l,d as o,e as r,w as n,b as e,r as i,o as p}from"./app-BaJBWwWi.js";const h={},f={class:"table-of-contents"};function b(k,t){const a=i("router-link"),d=i("Tip");return p(),u("div",null,[t[28]||(t[28]=l("h1",{id:"zookeeper",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#zookeeper"},[l("span",null,"Zookeeper")])],-1)),l("nav",f,[l("ul",null,[l("li",null,[r(a,{to:"#应用场景"},{default:n(()=>t[0]||(t[0]=[e("应用场景")])),_:1,__:[0]}),l("ul",null,[l("li",null,[r(a,{to:"#服务注册与发现"},{default:n(()=>t[1]||(t[1]=[e("服务注册与发现")])),_:1,__:[1]})]),l("li",null,[r(a,{to:"#数据发布-订阅-配置中心"},{default:n(()=>t[2]||(t[2]=[e("数据发布/订阅（配置中心）")])),_:1,__:[2]})]),l("li",null,[r(a,{to:"#命名服务"},{default:n(()=>t[3]||(t[3]=[e("命名服务")])),_:1,__:[3]})]),l("li",null,[r(a,{to:"#负载均衡"},{default:n(()=>t[4]||(t[4]=[e("负载均衡")])),_:1,__:[4]})]),l("li",null,[r(a,{to:"#集群管理"},{default:n(()=>t[5]||(t[5]=[e("集群管理")])),_:1,__:[5]})]),l("li",null,[r(a,{to:"#分布式协调与同步"},{default:n(()=>t[6]||(t[6]=[e("分布式协调与同步")])),_:1,__:[6]})]),l("li",null,[r(a,{to:"#分布式队列"},{default:n(()=>t[7]||(t[7]=[e("分布式队列")])),_:1,__:[7]})])])]),l("li",null,[r(a,{to:"#场景选择建议"},{default:n(()=>t[8]||(t[8]=[e("场景选择建议")])),_:1,__:[8]})]),l("li",null,[r(a,{to:"#实际应用案例"},{default:n(()=>t[9]||(t[9]=[e("实际应用案例")])),_:1,__:[9]})])])]),t[29]||(t[29]=l("p",null,"Zookeeper是一个高可用的分布式数据管理和协调框架，并且能够很好的保证分布式环境中数据的一致性。在越来越多的分布式系统（Hadoop、HBase、Kafka）中，Zookeeper都作为核心组件使用。",-1)),t[30]||(t[30]=l("h2",{id:"应用场景",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#应用场景"},[l("span",null,"应用场景")])],-1)),t[31]||(t[31]=l("p",null,"Zookeeper主要用于以下场景：",-1)),l("ul",null,[t[17]||(t[17]=l("li",null,[l("strong",null,"服务注册与发现")],-1)),t[18]||(t[18]=l("li",null,[l("strong",null,"数据发布/订阅（配置中心）")],-1)),t[19]||(t[19]=l("li",null,[l("strong",null,"命名服务")],-1)),t[20]||(t[20]=l("li",null,"负载均衡",-1)),t[21]||(t[21]=l("li",null,[e("集群管理 "),l("ul",null,[l("li",null,[l("strong",null,"Master选举")]),l("li",null,"节点监听")])],-1)),l("li",null,[t[14]||(t[14]=e("分布式协调与同步 ")),l("ul",null,[l("li",null,[t[11]||(t[11]=e("屏障")),r(d,null,{default:n(()=>t[10]||(t[10]=[e("DistributedBarrier")])),_:1,__:[10]})]),l("li",null,[t[13]||(t[13]=l("strong",null,"分布式锁",-1)),r(d,null,{default:n(()=>t[12]||(t[12]=[e("InterProcessMutex")])),_:1,__:[12]})])])]),l("li",null,[t[16]||(t[16]=e("分布式队列")),r(d,null,{default:n(()=>t[15]||(t[15]=[e("DistributedQueue")])),_:1,__:[15]})])]),t[32]||(t[32]=o('<h3 id="服务注册与发现" tabindex="-1"><a class="header-anchor" href="#服务注册与发现"><span>服务注册与发现</span></a></h3><ol><li>服务注册<br> 服务提供者将自身信息（如IP、端口、元数据）写入ZooKeeper的临时节点，节点随会话生命周期自动清理（服务下线时自动删除）。</li><li>服务发现<br> 服务消费者通过监听服务提供者的临时节点，获取到服务提供者的最新信息，并进行服务调用。</li></ol><p>ZooKeeper的服务注册与发现借鉴了发布/订阅的思想，但因其强一致性设计和特有的ZNode模型，更偏向于实时状态同步而非传统消息发布。对于需要高可靠服务发现的场景（如Dubbo、Kafka的Broker注册），这种模式比通用消息系统更合适。</p><table><thead><tr><th>特性</th><th>ZooKeeper服务发现</th><th>经典发布/订阅（如Kafka）</th></tr></thead><tbody><tr><td>数据模型</td><td>层次化节点（ZNode）</td><td>Topic/Message队列</td></tr><tr><td>触发方式</td><td>Watcher事件（一次性触发）</td><td>消息持久化，多订阅者消费</td></tr><tr><td>事件丢失风险</td><td>较高（需手动处理）</td><td>较低</td></tr><tr><td>数据一致性</td><td>强一致性（CP系统）</td><td>取决于实现（Kafka是AP）</td></tr><tr><td>服务状态管理</td><td>临时节点自动清理</td><td>需额外实现心跳检测</td></tr><tr><td>典型场景</td><td>动态服务列表更新</td><td>事件广播、日志流</td></tr></tbody></table><h4 id="watcher-事件的一次性触发机制" tabindex="-1"><a class="header-anchor" href="#watcher-事件的一次性触发机制"><span>Watcher 事件的一次性触发机制</span></a></h4><p>Watcher 事件一次性触发是指每个 Watcher 通知只会被触发一次，触发后即自动失效，需要重新注册才能继续监听后续变化。 单次生效原则：</p><ul><li>当监听的 ZNode 发生变化时，Watcher 会被触发</li><li>触发后该 Watcher 立即被 ZooKeeper 服务端移除</li><li>如需继续监听，必须重新设置 Watcher</li></ul><p>设计原因：</p><ul><li>性能考虑： 避免大量未处理的 Watcher 堆积在服务端，减少服务端维护 Watcher 状态的开销</li><li>简化一致性： 防止因网络问题导致的事件重复，确保客户端每次处理都是最新的状态变化</li><li>资源控制：防止客户端无限制注册 Watcher 导致内存泄漏</li></ul><p>事件丢失风险较高，需客户端自行处理重新注册，有两种解决方案：</p><ul><li>手动重新注册：客户端在处理变化后重试注册 Watcher</li><li>使用Curator的自动重新注册：Curator提供了NodeCache，可以自动重新注册 Watcher，实现对 ZNode 数据变化的持续监听。</li></ul><h3 id="数据发布-订阅-配置中心" tabindex="-1"><a class="header-anchor" href="#数据发布-订阅-配置中心"><span>数据发布/订阅（配置中心）</span></a></h3><p>数据发布/订阅系统，即配置中心。需要发布者将数据发布到Zookeeper的节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。 Zookeeper采用了推拉相结合的模式，客户端向服务端注册自己需要关注的节点，一旦该节点数据发生变更，那么服务端就会向相应的客户端推送Watcher事件通知，客户端接收到此通知后，主动到服务端获取最新的数据。 应用在启动时会主动到Zookeeper服务端上进行一次配置信息的获取，同时，在指定节点上注册一个Watcher监听，这样在配置信息发生变更，服务端都会实时通知所有订阅的客户端，从而达到实时获取最新配置的目的。</p><h3 id="命名服务" tabindex="-1"><a class="header-anchor" href="#命名服务"><span>命名服务</span></a></h3><p>命名服务是指将名称映射到实际资源或服务信息。</p><ul><li>唯一ID生成</li><li>全局命名空间 <ul><li>提供统一的资源命名方案</li><li>类似DNS但用于分布式系统内部</li></ul></li></ul><h3 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡"><span>负载均衡</span></a></h3><p>负载均衡是一种相当常见的计算机网络技术，用来对多个计算机、网络连接、CPU、磁盘驱动或其他资源进行分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间和避免过载的目的。</p><h3 id="集群管理" tabindex="-1"><a class="header-anchor" href="#集群管理"><span>集群管理</span></a></h3><h4 id="master选举" tabindex="-1"><a class="header-anchor" href="#master选举"><span>Master选举</span></a></h4><h3 id="分布式协调与同步" tabindex="-1"><a class="header-anchor" href="#分布式协调与同步"><span>分布式协调与同步</span></a></h3><h4 id="屏障" tabindex="-1"><a class="header-anchor" href="#屏障"><span>屏障</span></a></h4><ul><li>分布式系统中同步多个进程</li><li>实现MapReduce等需要同步的场景</li></ul><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h4>',24)),l("ul",null,[l("li",null,[t[23]||(t[23]=e("排他锁：同一时间只允许一个客户端访问资源 ")),r(d,null,{default:n(()=>t[22]||(t[22]=[e("InterProcessMutex")])),_:1,__:[22]})]),t[24]||(t[24]=l("li",null,"共享锁：多个客户端可同时读取，但写入时独占",-1))]),t[33]||(t[33]=l("h3",{id:"分布式队列",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#分布式队列"},[l("span",null,"分布式队列")])],-1)),l("ul",null,[l("li",null,[t[26]||(t[26]=e("普通队列")),r(d,null,{default:n(()=>t[25]||(t[25]=[e("DistributedQueue")])),_:1,__:[25]})]),t[27]||(t[27]=l("li",null,"优先级队列：基于节点序列号实现优先级",-1))]),t[34]||(t[34]=o('<h2 id="场景选择建议" tabindex="-1"><a class="header-anchor" href="#场景选择建议"><span>场景选择建议</span></a></h2><table><thead><tr><th>应用场景</th><th>推荐ZooKeeper特性</th><th>替代方案</th></tr></thead><tbody><tr><td>分布式锁</td><td>临时顺序节点 + Watcher</td><td>Redis, etcd</td></tr><tr><td>配置中心</td><td>持久节点 + Watcher</td><td>Apollo, Nacos</td></tr><tr><td>服务发现</td><td>临时节点 + 子节点监听</td><td>Eureka, Consul</td></tr><tr><td>选举机制</td><td>临时节点 + 最小序列号策略</td><td>etcd, Consul</td></tr><tr><td>命名服务</td><td>持久顺序节点</td><td>数据库序列</td></tr></tbody></table><h2 id="实际应用案例" tabindex="-1"><a class="header-anchor" href="#实际应用案例"><span>实际应用案例</span></a></h2><ul><li>Dubbo：服务注册与发现</li></ul>',4))])}const x=s(h,[["render",b]]),g=JSON.parse('{"path":"/posts/arch/zookeeper/","title":"Zookeeper","lang":"zh-CN","frontmatter":{"title":"Zookeeper","date":"2025-07-14T01:16:53.997Z","category":["arch","zookeeper"],"tags":["arch","zookeeper"]},"git":{"updatedTime":1752561310000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"e5512f7153d6d6bfe2919c55419f1a8ef5e3fc96","time":1752561310000,"email":"3036190149@qq.com","author":"zhaomy","message":"1. Zookeeper 2. Java工具库"}]},"filePathRelative":"posts/arch/zookeeper/index.md","excerpt":"\\n\\n<p>Zookeeper是一个高可用的分布式数据管理和协调框架，并且能够很好的保证分布式环境中数据的一致性。在越来越多的分布式系统（Hadoop、HBase、Kafka）中，Zookeeper都作为核心组件使用。</p>\\n<h2>应用场景</h2>\\n<p>Zookeeper主要用于以下场景：</p>\\n<ul>\\n<li><strong>服务注册与发现</strong></li>\\n<li><strong>数据发布/订阅（配置中心）</strong></li>\\n<li><strong>命名服务</strong></li>\\n<li>负载均衡</li>\\n<li>集群管理\\n<ul>\\n<li><strong>Master选举</strong></li>\\n<li>节点监听</li>\\n</ul>\\n</li>\\n<li>分布式协调与同步\\n<ul>\\n<li>屏障</li>\\n<li><strong>分布式锁</strong></li>\\n</ul>\\n</li>\\n<li>分布式队列</li>\\n</ul>"}');export{x as comp,g as data};
