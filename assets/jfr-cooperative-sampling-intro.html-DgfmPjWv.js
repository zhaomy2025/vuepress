import{_ as a,c as e,d as l,o as i}from"./app-REDOwCgz.js";const n={};function o(s,t){return i(),e("div",null,t[0]||(t[0]=[l('<h3 id="问题-异步采样为何不稳定" tabindex="-1"><a class="header-anchor" href="#问题-异步采样为何不稳定"><span>问题：异步采样为何不稳定？</span></a></h3><ul><li>异步采样 指 JFR 在 不停止业务线程 的情况下，随时抓取线程的调用栈。</li><li>旧实现直接在任意时刻“爬栈”，会遇到两类崩溃：</li></ul><ol><li>线程正好在执行 JIT 刚编译完但尚未完全同步的代码 ，栈帧结构不完整 → 爬栈越界。</li><li>线程正在 去优化（deoptimization） 的临界区 → 栈信息不一致。 结果：JVM 偶尔 crash，或者采样数据出现“幽灵栈帧”。</li></ol><h3 id="旧方案的权衡-要么-安全-要么-失真" tabindex="-1"><a class="header-anchor" href="#旧方案的权衡-要么-安全-要么-失真"><span>旧方案的权衡：要么“安全”要么“失真”</span></a></h3><table><thead><tr><th>方案</th><th>做法</th><th>缺点</th></tr></thead><tbody><tr><td>Stop-the-world</td><td>让所有线程进入 safepoint 后再采样</td><td>业务停顿（几十毫秒），破坏低延迟场景</td></tr><tr><td>冒险异步</td><td>直接爬栈，不做全局停顿</td><td>不稳定，可能 JVM 崩溃</td></tr></tbody></table><h3 id="新方案-只在-safepoint-采样-但最小化-safepoint-偏差" tabindex="-1"><a class="header-anchor" href="#新方案-只在-safepoint-采样-但最小化-safepoint-偏差"><span>新方案：只在 safepoint 采样，但最小化 safepoint 偏差</span></a></h3><ul><li>核心思想 <ul><li>把“采样请求”投递给目标线程，线程自愿在下一个 safepoint 完成采样；采样动作仍由业务线程自己执行，但必须在 safepoint 内完成，保证栈结构一致。</li></ul></li><li>关键机制 <ul><li>协作标志 <ul><li>JFR 给每个 Java 线程置位一个<code>_should_sample_at_safepoint</code>标志。</li></ul></li><li>safepoint 轮询：线程在 safepoint 检查点发现该标志为真，立即： <ul><li>保存当前 rbp/rsp 等寄存器 → 构建可信栈帧。</li><li>把栈信息写入 JFR 缓冲区。</li></ul></li><li>偏差控制 <ul><li>不强制全局停顿：仅对“被采样线程”做一次轻量级 handshake，其他线程继续跑。</li><li>时间窗口限制：若线程长时间未进入 safepoint（例如死循环内无 safepoint poll），采样请求超时放弃，避免饥饿。</li></ul></li></ul></li><li>实现细节 <ul><li>Handshakes（JDK 15+ 引入）：单线程级 safepoint，不波及整个 JVM。</li><li>偏向采样：默认只采样“运行中”线程，sleep/block 的线程直接跳过，减少无效 safepoint。</li><li>自适应阈值：根据历史采样成功率动态调整超时时间，防止过度放弃或过度停顿。</li></ul></li></ul><h3 id="一句话总结" tabindex="-1"><a class="header-anchor" href="#一句话总结"><span>一句话总结</span></a></h3><p>JEP 518 把 “安全”与“低延迟” 从对立变为兼得 —— 线程自己走进安全点采样，既保证栈可信，又把停顿缩小到单线程级。</p>',9)]))}const h=a(n,[["render",o]]),r=JSON.parse('{"path":"/java/new-features/jfr-cooperative-sampling-intro.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1757914089000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/jfr-cooperative-sampling-intro.md","excerpt":"<h3>问题：异步采样为何不稳定？</h3>\\n<ul>\\n<li>异步采样 指 JFR 在 不停止业务线程 的情况下，随时抓取线程的调用栈。</li>\\n<li>旧实现直接在任意时刻“爬栈”，会遇到两类崩溃：</li>\\n</ul>\\n<ol>\\n<li>线程正好在执行 JIT 刚编译完但尚未完全同步的代码 ，栈帧结构不完整 → 爬栈越界。</li>\\n<li>线程正在 去优化（deoptimization） 的临界区 → 栈信息不一致。 结果：JVM 偶尔 crash，或者采样数据出现“幽灵栈帧”。</li>\\n</ol>\\n<h3>旧方案的权衡：要么“安全”要么“失真”</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>方案</th>\\n<th>做法</th>\\n<th>缺点</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Stop-the-world</td>\\n<td>让所有线程进入 safepoint 后再采样</td>\\n<td>业务停顿（几十毫秒），破坏低延迟场景</td>\\n</tr>\\n<tr>\\n<td>冒险异步</td>\\n<td>直接爬栈，不做全局停顿</td>\\n<td>不稳定，可能 JVM 崩溃</td>\\n</tr>\\n</tbody>\\n</table>"}');export{h as comp,r as data};
