import{_ as d,c as m,a as n,d as l,e as t,w as e,b as s,r as c,o as h}from"./app-DhQSeJGz.js";const v={},k={class:"table-of-contents"};function f(g,a){const i=c("router-link"),p=c("RouteLink"),u=c("CodeTabs");return h(),m("div",null,[a[24]||(a[24]=n("h1",{id:"java-23-新特性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#java-23-新特性"},[n("span",null,"Java 23 新特性")])],-1)),n("nav",k,[n("ul",null,[n("li",null,[t(i,{to:"#概述"},{default:e(()=>a[0]||(a[0]=[s("概述")])),_:1,__:[0]})]),n("li",null,[t(i,{to:"#主要新特性"},{default:e(()=>a[1]||(a[1]=[s("主要新特性")])),_:1,__:[1]}),n("ul",null,[n("li",null,[t(i,{to:"#jep-455-模式、instanceof-和-switch中的原始类型-预览"},{default:e(()=>a[2]||(a[2]=[s("JEP 455: 模式、instanceof 和 switch中的原始类型（预览）")])),_:1,__:[2]})]),n("li",null,[t(i,{to:"#jer-466-类文件-api-第二次预览"},{default:e(()=>a[3]||(a[3]=[s("JER 466: 类文件 API（第二次预览）")])),_:1,__:[3]})]),n("li",null,[t(i,{to:"#jer-467-markdown-文档注释"},{default:e(()=>a[4]||(a[4]=[s("JER 467: Markdown 文档注释")])),_:1,__:[4]})]),n("li",null,[t(i,{to:"#jer-469-向量-api-第八个孵化器"},{default:e(()=>a[5]||(a[5]=[s("JER 469: 向量 API (第八个孵化器)")])),_:1,__:[5]})]),n("li",null,[t(i,{to:"#jer-471-弃用-sun-misc-unsafe-中的内存访问方法-以便删除"},{default:e(()=>a[6]||(a[6]=[s("JER 471: 弃用 sun.misc.Unsafe 中的内存访问方法，以便删除")])),_:1,__:[6]})]),n("li",null,[t(i,{to:"#jep-473-流收集器-第二次预览"},{default:e(()=>a[7]||(a[7]=[s("JEP 473: 流收集器（第二次预览）")])),_:1,__:[7]})]),n("li",null,[t(i,{to:"#jer-474-zgc-默认的分代模式"},{default:e(()=>a[8]||(a[8]=[s("JER 474: ZGC: 默认的分代模式")])),_:1,__:[8]})]),n("li",null,[t(i,{to:"#jep-476-模块导入声明-预览"},{default:e(()=>a[9]||(a[9]=[s("JEP 476: 模块导入声明（预览）")])),_:1,__:[9]})]),n("li",null,[t(i,{to:"#jep-477-隐式声明的类和实例主方法-第三次预览"},{default:e(()=>a[10]||(a[10]=[s("JEP 477: 隐式声明的类和实例主方法（第三次预览）")])),_:1,__:[10]})]),n("li",null,[t(i,{to:"#jep-480-结构化并发-第三次预览"},{default:e(()=>a[11]||(a[11]=[s("JEP 480: 结构化并发（第三次预览）")])),_:1,__:[11]})]),n("li",null,[t(i,{to:"#jep-481-作用域值-第三次预览"},{default:e(()=>a[12]||(a[12]=[s("JEP 481: 作用域值（第三次预览）")])),_:1,__:[12]})]),n("li",null,[t(i,{to:"#jep-482-灵活的构造函数体-第二次预览"},{default:e(()=>a[13]||(a[13]=[s("JEP 482: 灵活的构造函数体（第二次预览）")])),_:1,__:[13]})])])])])]),a[25]||(a[25]=l('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>Java 23 于 2024 年 9 月发布，包含了多个新特性和改进。</p><h2 id="主要新特性" tabindex="-1"><a class="header-anchor" href="#主要新特性"><span>主要新特性</span></a></h2><h3 id="jep-455-模式、instanceof-和-switch中的原始类型-预览" tabindex="-1"><a class="header-anchor" href="#jep-455-模式、instanceof-和-switch中的原始类型-预览"><span>JEP 455: 模式、instanceof 和 switch中的原始类型（预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Enhance pattern matching by allowing primitive type patterns in all pattern contexts, and extend instanceof and switch to work with all primitive types. This is a preview language feature.</p></div><p>JEP 488 在模式匹配的上下文中允许<strong>原始类型模式与对应包装类型之间的宽松转换</strong>，并支持<strong>对记录组件的类型宽松匹配</strong>。核心贡献是：</p><ul><li><p>原始类型模式与对应包装类型之间的宽松转换</p><ul><li>增强 instanceof 和 switch 构造以支持原始类型模式作为顶级模式：允许在模式匹配中直接使用原始类型（如 <code>int p</code>）来匹配包装类（如 <code>Integer</code>）的对象。</li><li>增强记录模式以支持类型转换：允许在记录模式中使用原始类型来匹配包装类型的记录组件值，无需严格匹配包装类型。</li></ul></li><li><p>对记录组件的类型宽松匹配：在记录模式中使用原始类型来匹配记录的组件值时，无需严格匹配原始类型。这一机制支持在解构记录时自动完成原始类型的加宽转换和有条件的安全缩窄转换，显著提升了代码的简洁性与灵活性。</p></li><li><p>安全性</p><ul><li>妥善处理 null 值，原始类型模式不会匹配 null，从而避免了潜在的 NullPointerException。</li><li>对于记录模式中可能造成信息丢失的缩窄转换（如 double → int），模式匹配会在运行时自动检查值的兼容性，仅在不丢失信息时完成匹配，否则返回 false，保障匹配过程的安全性与可靠性。</li></ul></li><li><p>语法与一致性更新：引入了相应的支配性检查规则，在同一个 switch 块中，原始类型模式（如 int i）和其对应的包装类型模式（如 Integer i）不能同时存在，因为它们会互相导致对方不可到达，无论顺序如何都会编译报错。记录模式也遵循相同的类型转换原则，进一步强化了模式匹配整体的语言一致性和表达力。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>模式 (Pattern)是一个通用概念，指的是在条件判断中同时进行类型检查和变量绑定的操作。例如：obj instanceof String s 就是一个类型模式，它同时检查 obj 是否是 String 类型，如果是，则将其绑定到变量 s。</p><p>instanceof 运算符是应用类型模式的第一个地方。从 Java 16 开始，instanceof 后面可以直接跟一个类型模式和变量名。</p><p>switch 表达式/语句是应用多种模式（包括类型模式、常量模式等）的更强大场所。在 Java 17 和 21 中，switch 的能力被大幅增强，case 标签可以支持模式。</p><p>所以三者关系是：模式匹配是一个范式；instanceof 和 switch 是应用该范式的语法工具。</p><p>因此，对JEP 488最准确的理解是：为模式、instanceof 和 switch 添加对原始类型的支持。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>自动加宽转换： 使用一个 “较宽”的类型模式 (double) 去匹配一个 “较窄”的组件类型 (int) 的值。编译器允许这种操作，并自动完成安全的值转换。</p><p>有条件的安全缩窄转换： 缩窄转换是一种可能丢失信息的转换（例如，将 double 3.14 转换为 int 3 会丢失小数部分），因此不是无条件进行的。</p><ul><li>JVM 会先检查这个 double 值是否能完全精确地转换为一个 int 值（即没有小数部分，且在 int 的取值范围内）</li><li>如果检查通过：模式匹配成功，变量被赋值</li><li>如果检查不通过（值太大或有小数）：模式匹配直接返回 false，不会赋值，也不会抛出异常</li></ul><p>注意：</p><ul><li>“自动加宽转换”和“有条件的安全缩窄转换”要求初始类型和目标类型都是原始类型。</li></ul></div>',9)),n("p",null,[t(p,{to:"/java/new-features/primitive-types-in-patterns-instanceof-and-switch.html"},{default:e(()=>a[14]||(a[14]=[s("模式、instanceof 和 switch中的原始类型")])),_:1,__:[14]})]),a[26]||(a[26]=l('<h3 id="jer-466-类文件-api-第二次预览" tabindex="-1"><a class="header-anchor" href="#jer-466-类文件-api-第二次预览"><span>JER 466: 类文件 API（第二次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 466: Class-File API (Second Preview)</p><p>Provide a standard API for parsing, generating, and transforming Java class files. This is a preview API.</p></div><p>提供了一个用于解析、生成和转换 Java 类文件的标准 API，旨在替代第三方库（如 ASM）。</p><ul><li>解析（Parsing）：指的是读取一个已编译的<code>.class</code>文件，并将其内容（如魔数、版本号、常量池、方法、字段等）分解成程序可以理解和操作的结构化数据模型。</li><li>生成（Generation）：指的是从零开始，通过编程方式动态地创建出一个全新的、符合规范的<code>.class</code>文件。</li><li>转换（Transformation）：指的是读取一个现有的<code>.class</code>文件，对其结构进行修改（例如，添加/删除方法、修改字节码指令、植入分析代码等），然后输出修改后的新类文件。</li><li>标准 API（Standard API）：这是最关键的一点。这意味着该API是Java平台本身的一部分（例如在<code>java.lang.classfile</code>包下），由OpenJDK官方维护和发布。用户无需再引入额外的第三方JAR包。</li></ul><h3 id="jer-467-markdown-文档注释" tabindex="-1"><a class="header-anchor" href="#jer-467-markdown-文档注释"><span>JER 467: Markdown 文档注释</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 467: Markdown Documentation Comments</p><p>Enable JavaDoc documentation comments to be written in Markdown rather than solely in a mixture of HTML and JavaDoc @-tags.</p></div><p>允许JavaDoc文档注释使用Markdown语法编写，而不再仅限于HTML和JavaDoc @-tags的混合格式。</p><h3 id="jer-469-向量-api-第八个孵化器" tabindex="-1"><a class="header-anchor" href="#jer-469-向量-api-第八个孵化器"><span>JER 469: 向量 API (第八个孵化器)</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 469: Vector API (Eighth Incubator)</p><p>Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations.</p></div><p>引入一个 API 来表达矢量计算，这些计算在运行时可靠地编译为受支持的 CPU 上的最佳矢量指令，从而实现优于等效标量计算的性能。</p>',10)),n("p",null,[t(p,{to:"/java/new-features/vector-api-guide.html"},{default:e(()=>a[15]||(a[15]=[s("向量 API")])),_:1,__:[15]})]),a[27]||(a[27]=l(`<h3 id="jer-471-弃用-sun-misc-unsafe-中的内存访问方法-以便删除" tabindex="-1"><a class="header-anchor" href="#jer-471-弃用-sun-misc-unsafe-中的内存访问方法-以便删除"><span>JER 471: 弃用 sun.misc.Unsafe 中的内存访问方法，以便删除</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 471: Deprecate the Memory-Access Methods in sun.misc.Unsafe for Removal</p><p>Deprecate the memory-access methods in sun.misc.Unsafe for removal in a future release. These unsupported methods have been superseded by standard APIs, namely the VarHandle API (JEP 193, JDK 9) and the Foreign Function &amp; Memory API (JEP 454, JDK 22). We strongly encourage library developers to migrate from sun.misc.Unsafe to supported replacements, so that applications can migrate smoothly to modern JDK releases.</p></div><p>弃用 sun.misc.Unsafe 的内存访问方法以便在未来的版本中移除。这些不受支持的方法已被标准 API 取代，即 VarHandle API（JEP 193，JDK 9）和外部函数与内存 API（JEP 454，JDK 22）。我们强烈建议库开发者从 sun.misc.Unsafe 迁移到受支持的替代方案，以便应用程序能够顺利迁移到现代 JDK 版本。</p><h3 id="jep-473-流收集器-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-473-流收集器-第二次预览"><span>JEP 473: 流收集器（第二次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 473: Stream Gatherers (Second Preview)</p><p>Enhance the Stream API to support custom intermediate operations. This will allow stream pipelines to transform data in ways that are not easily achievable with the existing built-in intermediate operations. This is a preview API.</p></div><p>流收集器（Stream Gatherers）能为Stream API轻松添加自定义的中间操作，实现更复杂的数据转换。</p><h3 id="jer-474-zgc-默认的分代模式" tabindex="-1"><a class="header-anchor" href="#jer-474-zgc-默认的分代模式"><span>JER 474: ZGC: 默认的分代模式</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 474: ZGC: Generational Mode by Default</p><p>Switch the default mode of the Z Garbage Collector (ZGC) to the generational mode. Deprecate the non-generational mode, with the intent to remove it in a future release.</p></div><p>将 Z 垃圾回收器（ZGC）的默认模式切换为分代模式。弃用非分代模式，并计划在未来的版本中移除该模式。</p><h3 id="jep-476-模块导入声明-预览" tabindex="-1"><a class="header-anchor" href="#jep-476-模块导入声明-预览"><span>JEP 476: 模块导入声明（预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 476: Module Import Declarations (Preview)</p><p>Enhance the Java programming language with the ability to succinctly import all of the packages exported by a module. This simplifies the reuse of modular libraries, but does not require the importing code to be in a module itself. This is a preview language feature.</p></div><p>增强 Java 编程语言，使其能够简洁地导入某个模块所导出的所有包。这简化了模块化库的重用，且调用方代码自身不必是模块化的。这是一项预览语言特性。</p><p><strong>使用新特性导入整个模块</strong> 假设有一个名为 com.example.utils 的模块，其 module-info.java 文件导出了了一些包：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// module-info.java</span></span>
<span class="line"><span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在另一个非模块化的应用程序（即没有 module-info.java）中，现在可以使用一种新的导入语句来一次性导入 com.example.utils 模块导出的所有包。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// 使用 &#39;import module&#39; 关键字一次性导入整个模块的所有导出包</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 现在可以直接使用被导入模块中所有导出包下的类，而无需逐个导入</span></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.math 包</span></span>
<span class="line">    <span class="token class-name">Calculator</span> calc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">double</span> result <span class="token operator">=</span> calc<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.logging 包</span></span>
<span class="line">    <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Result is: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与之前方式的对比</strong></p>`,17)),n("ul",null,[a[21]||(a[21]=l(`<li>方式一（传统非模块化项目）： 必须逐个导入所需的每个类或包。<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">Calculator</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// ... 还需要导入其他要用的类 ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1)),n("li",null,[a[20]||(a[20]=s("方式二（模块化项目）： 即使只想用一两个类，也必须在自己的 module-info.java 中声明对整个模块的依赖。")),t(u,{id:"258",data:[{id:"module-info.java"},{id:"MyApp.java"}]},{title0:e(({value:o,isActive:r})=>a[16]||(a[16]=[s("module-info.java")])),title1:e(({value:o,isActive:r})=>a[17]||(a[17]=[s("MyApp.java")])),tab0:e(({value:o,isActive:r})=>a[18]||(a[18]=[n("div",{class:"language-java line-numbers-mode","data-highlighter":"prismjs","data-ext":"java"},[n("pre",null,[n("code",null,[n("span",{class:"line"},[n("span",{class:"token keyword"},"module"),s(),n("span",{class:"token namespace"},[s("my"),n("span",{class:"token punctuation"},"."),s("app")]),s(),n("span",{class:"token punctuation"},"{")]),s(`
`),n("span",{class:"line"},[s("  "),n("span",{class:"token keyword"},"requires"),s(),n("span",{class:"token namespace"},[s("com"),n("span",{class:"token punctuation"},"."),s("example"),n("span",{class:"token punctuation"},"."),s("utils")]),n("span",{class:"token punctuation"},";")]),s(`
`),n("span",{class:"line"},[s("  "),n("span",{class:"token comment"},"// ... 其他依赖 ...")]),s(`
`),n("span",{class:"line"},[n("span",{class:"token punctuation"},"}")]),s(`
`),n("span",{class:"line"})])]),n("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1)])),tab1:e(({value:o,isActive:r})=>a[19]||(a[19]=[n("div",{class:"language-java line-numbers-mode","data-highlighter":"prismjs","data-ext":"java"},[n("pre",null,[n("code",null,[n("span",{class:"line"},[n("span",{class:"token keyword"},"import"),s(),n("span",{class:"token namespace"},[s("com"),n("span",{class:"token punctuation"},"."),s("example"),n("span",{class:"token punctuation"},"."),s("utils"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token punctuation"},"."),s("math"),n("span",{class:"token punctuation"},"."),s("Calculator"),n("span",{class:"token punctuation"},";")]),s(`
`),n("span",{class:"line"})])]),n("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[n("div",{class:"line-number"})])],-1)])),_:1})]),a[22]||(a[22]=n("li",null,[s("使用新特性后的方式（简洁且无需模块化）： "),n("ul",null,[n("li",null,"无需自身的 module-info.java。"),n("li",null,"一行语句 import module com.example.utils.*; 即可获得该模块所有导出包的访问权，无需再写多个 import 语句。")])],-1))]),a[28]||(a[28]=l(`<h3 id="jep-477-隐式声明的类和实例主方法-第三次预览" tabindex="-1"><a class="header-anchor" href="#jep-477-隐式声明的类和实例主方法-第三次预览"><span>JEP 477: 隐式声明的类和实例主方法（第三次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 477: Implicitly Declared Classes and Instance Main Methods (Third Preview)</p><p>Evolve the Java programming language so that beginners can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of the language, beginners can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. Experienced developers can likewise enjoy writing small programs succinctly, without the need for constructs intended for programming in the large. This is a preview language feature.</p></div><p>发展 Java 编程语言，使初学者无需了解专为大型程序设计的语言功能，即可编写自己的第一个程序。初学者无需使用某种独立的语言变体，即可为单类程序编写简化的声明，然后随着技能的增长无缝扩展他们的程序以使用更高级的功能。经验丰富的开发者同样可以简洁地编写小型程序，而不必使用那些为大规模编程设计的结构。</p><p>简单说就是省略显式类声明和 public static 修饰符，简化输出语句，来简化入门代码和脚本开发。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Java 23!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式调用 System.out.println</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="jep-480-结构化并发-第三次预览" tabindex="-1"><a class="header-anchor" href="#jep-480-结构化并发-第三次预览"><span>JEP 480: 结构化并发（第三次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 480: Structured Concurrency (Third Preview)</p><p>Simplify concurrent programming by introducing an API for structured concurrency. Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API.</p></div><p>通过引入结构化并发 API 来简化并发编程。结构化并发将不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。这是一个预览 API。</p>`,8)),n("p",null,[t(p,{to:"/java/new-features/structured-concurrency-guide.html"},{default:e(()=>a[23]||(a[23]=[s("结构化并发")])),_:1,__:[23]})]),a[29]||(a[29]=l('<h3 id="jep-481-作用域值-第三次预览" tabindex="-1"><a class="header-anchor" href="#jep-481-作用域值-第三次预览"><span>JEP 481: 作用域值（第三次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 481: Scoped Values (Third Preview)</p><p>Introduce scoped values, which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads (JEP 444) and structured concurrency (JEP 480). This is a preview API.</p></div><p>用于在线程内和跨线程共享不可变数据，旨在替代 <code>ThreadLocal</code>，特别是在虚拟线程场景下更高效、更安全。</p><h3 id="jep-482-灵活的构造函数体-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-482-灵活的构造函数体-第二次预览"><span>JEP 482: 灵活的构造函数体（第二次预览）</span></a></h3><div class="hint-container info"><p class="hint-container-title">JEP 482: Flexible Constructor Bodies (Second Preview)</p><p>In constructors in the Java programming language, allow statements to appear before an explicit constructor invocation, i.e., super(..) or this(..). The statements cannot reference the instance under construction, but they can initialize its fields. Initializing fields before invoking another constructor makes a class more reliable when methods are overridden. This is a preview language feature.</p></div><p>在 Java 编程语言的构造函数中，允许在显式构造函数调用（即 super(..) 或 this(..)）之前出现语句。这些语句不能引用正在构建的实例，但可以初始化其字段。在调用另一个构造函数之前初始化字段，可以在方法被重写时提高类的可靠性。这是一个预览语言特性。</p>',6))])}const w=d(v,[["render",f]]),j=JSON.parse('{"path":"/java/new-features/java-23-features.html","title":"Java 23 新特性","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1757924168000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":4,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"18f0d4a4f1d4c588016a7d0c04145c1731b60fee","time":1757924168000,"email":"3036190149@qq.com","author":"zhaomy","message":"java22新特性 &#x26; java23-25新特性修改"},{"hash":"851f930c21b5795fb0fdbec07cd7508fd1e84baf","time":1757919665000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 23 新特性"},{"hash":"a56dd23708c5d2f36ccc4bf8fe2380b4e747453c","time":1757919595000,"email":"3036190149@qq.com","author":"zhaomy","message":"java24、java25新特性修改"},{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/java-23-features.md","excerpt":"\\n\\n<h2>概述</h2>\\n<p>Java 23 于 2024 年 9 月发布，包含了多个新特性和改进。</p>\\n<h2>主要新特性</h2>\\n<h3>JEP 455: 模式、instanceof 和 switch中的原始类型（预览）</h3>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>Enhance pattern matching by allowing primitive type patterns in all pattern contexts, and extend instanceof and switch to work with all primitive types. This is a preview language feature.</p>\\n</div>"}');export{w as comp,j as data};
