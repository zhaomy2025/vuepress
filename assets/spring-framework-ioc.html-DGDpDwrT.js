import{_ as l,c as r,a as e,d,e as n,w as o,r as p,o as s,b as i}from"./app-Cb6tOVs8.js";const c={},h={class:"table-of-contents"};function u(b,t){const a=p("router-link");return s(),r("div",null,[t[14]||(t[14]=e("h1",{id:"spring核心-ioc容器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#spring核心-ioc容器"},[e("span",null,"Spring核心 - IoC容器")])],-1)),e("nav",h,[e("ul",null,[e("li",null,[n(a,{to:"#容器概述"},{default:o(()=>t[0]||(t[0]=[i("容器概述")])),_:1,__:[0]}),e("ul",null,[e("li",null,[n(a,{to:"#applicationcontext"},{default:o(()=>t[1]||(t[1]=[i("ApplicationContext")])),_:1,__:[1]})]),e("li",null,[n(a,{to:"#beanfactory-和-applicationcontext-的区别"},{default:o(()=>t[2]||(t[2]=[i("BeanFactory 和 ApplicationContext 的区别")])),_:1,__:[2]})])])]),e("li",null,[n(a,{to:"#配置元数据"},{default:o(()=>t[3]||(t[3]=[i("配置元数据")])),_:1,__:[3]}),e("ul",null,[e("li",null,[n(a,{to:"#ioc-配置方式"},{default:o(()=>t[4]||(t[4]=[i("IoC 配置方式")])),_:1,__:[4]})])])]),e("li",null,[n(a,{to:"#bean"},{default:o(()=>t[5]||(t[5]=[i("Bean")])),_:1,__:[5]}),e("ul",null,[e("li",null,[n(a,{to:"#bean生命周期"},{default:o(()=>t[6]||(t[6]=[i("Bean生命周期")])),_:1,__:[6]})])])]),e("li",null,[n(a,{to:"#依赖注入"},{default:o(()=>t[7]||(t[7]=[i("依赖注入")])),_:1,__:[7]}),e("ul",null,[e("li",null,[n(a,{to:"#依赖注入方式"},{default:o(()=>t[8]||(t[8]=[i("依赖注入方式")])),_:1,__:[8]})]),e("li",null,[n(a,{to:"#自动装配"},{default:o(()=>t[9]||(t[9]=[i("自动装配")])),_:1,__:[9]})])])]),e("li",null,[n(a,{to:"#常见问题"},{default:o(()=>t[10]||(t[10]=[i("常见问题")])),_:1,__:[10]}),e("ul",null,[e("li",null,[n(a,{to:"#ioc-和-di-的区别"},{default:o(()=>t[11]||(t[11]=[i("IoC 和 DI 的区别")])),_:1,__:[11]})]),e("li",null,[n(a,{to:"#ioc配置和依赖注入的关系"},{default:o(()=>t[12]||(t[12]=[i("Ioc配置和依赖注入的关系？")])),_:1,__:[12]})]),e("li",null,[n(a,{to:"#ioc-的实现机制"},{default:o(()=>t[13]||(t[13]=[i("IoC 的实现机制")])),_:1,__:[13]})])])])])]),t[15]||(t[15]=d('<h2 id="容器概述" tabindex="-1"><a class="header-anchor" href="#容器概述"><span>容器概述</span></a></h2><p><code>ApplicationContext</code> 接口代表 Spring IoC 容器，容器通过读取配置元数据获取指令来实例化、配置并组装 Bean。<br> Spring 有两种IoC容器：<code>BeanFactory</code> 和 <code>ApplicationContext</code>。</p><ul><li>BeanFactory就像一个包含 Bean 集合的工厂类。</li><li>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h3 id="applicationcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext"><span>ApplicationContext</span></a></h3><p><code>ApplicationContext</code>内置如下功能：</p><ul><li>MessageSource：管理 Message ，实现国际化等功能。</li><li>ApplicationEventPublisher：事件发布。</li><li>ResourcePatternResolver：多资源加载。</li><li>EnvironmentCapable：系统 Environment（profile + Properties）相关。</li><li>Lifecycle：管理生命周期。</li><li>Closable：关闭，释放资源</li><li>InitializingBean：自定义初始化。</li><li>BeanNameAware：设置 beanName 的 Aware 接口。</li></ul><p><code>ApplicationContext</code>接口有以下几个主要实现类：</p><ul><li><p>从注解类中加载配置元数据</p><ul><li><code>AnnotationConfigApplicationContext</code>：从Java配置类中加载配置元数据</li><li><code>AnnotationConfigWebApplicationContext</code>：从Java配置类中加载配置元数据，并支持 Web 应用</li></ul></li><li><p>从XML配置文件中加载配置元数据</p><ul><li><code>ClassPathXmlApplicationContext</code>：从类路径下加载XML配置文件</li><li><code>FileSystemXmlApplicationContext</code>：从文件系统中加载XML配置文件</li><li><code>XmlWebApplicationContext</code>：从XML配置文件中加载配置元数据，并支持 Web 应用</li></ul></li><li><p>从Groovy脚本中加载配置元数据</p><ul><li><code>GenericGroovyApplicationContext</code>：从Groovy脚本中加载配置元数据</li></ul></li><li><p>Spring Boot 使用的 ApplicationContext 容器</p><ul><li>ConfigServletWebServerApplicationContext</li></ul><p>独立应用程序中通常创建<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>实例。</p></li></ul><h3 id="beanfactory-和-applicationcontext-的区别" tabindex="-1"><a class="header-anchor" href="#beanfactory-和-applicationcontext-的区别"><span>BeanFactory 和 ApplicationContext 的区别</span></a></h3><table><thead><tr><th>特性</th><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>何时实例化Bean</td><td>在客户端要求时实例化 Bean 对象</td><td>自动初始化非懒加载的 Bean 对象们</td></tr><tr><td>如何管理资源对象</td><td>使用语法显式提供资源对象</td><td>自己创建和管理资源对象</td></tr></tbody></table><p>默认情况下 ApplicationContext 实现会预先实例化单例 bean，这样可以ApplicationContext 创建时发现配置问题。</p><h2 id="配置元数据" tabindex="-1"><a class="header-anchor" href="#配置元数据"><span>配置元数据</span></a></h2><p>配置元数据可以表示为带注解的组件类、具有工厂方法的配置类、外部 XML 文件或 Groovy 脚本（不常用）。Spring IoC 容器通过读取配置元数据获取指令，实例化、配置并组装 Bean。</p><h3 id="ioc-配置方式" tabindex="-1"><a class="header-anchor" href="#ioc-配置方式"><span>IoC 配置方式</span></a></h3><p>Ioc配置关注如何定义和组装Bean，即告诉 Spring 容器如何管理对象及其依赖关系。根据配置元数据的不同，常用的IoC配置可以分为XML配置、Java配置类和注解配置三种方式：</p><ul><li>优先使用<strong>注解配置</strong> ：在应用程序的组件类上使用基于注解的配置元数据定义 bean。（<code>@CompentScan</code> + <code>@Component</code>） <ul><li>当前项目可用，但在starter中一般不用这种方法（<code>@Component</code>文件中有包名，不能直接复用）</li></ul></li><li>复杂配置结合<strong>Java配置类</strong>：在Java配置类上定义应用程序外部的bean。(<code>@Configuration</code>+<code>@Bean</code>) <ul><li>starter中常用的方法</li></ul></li><li>逐步淘汰<strong>XML配置</strong>（<code>@importResource</code>+XML文件）</li></ul><h4 id="java配置类" tabindex="-1"><a class="header-anchor" href="#java配置类"><span>Java配置类</span></a></h4><p>默认加载启动类所在包的配置类，可通过以下方式加载其他包的配置类：</p><ul><li>通过 @Import 显式导入配置类</li><li>通过 @ComponentScan 扩展扫描路径</li><li>通过 @SpringBootApplication(scanBasePackages) 扩展扫描路径</li></ul><h4 id="xml配置" tabindex="-1"><a class="header-anchor" href="#xml配置"><span>XML配置</span></a></h4><p>XML配置不推荐使用，具体用法参考<a href="https://docs.spring.io/spring-framework/reference/core/beans/basics.html" target="_blank" rel="noopener noreferrer">官方文档</a>，这里只给出一些使用建议并介绍常见的一些XML配置文件。<br> 使用建议：</p><ul><li>避免使用相对路径引用上级目录的资源文件，推荐使用绝对路径</li><li>更换环境时资源的绝对路径可能会变更，可以考虑使用占位符<code>${…}</code></li></ul><h2 id="bean" tabindex="-1"><a class="header-anchor" href="#bean"><span>Bean</span></a></h2><p>bean 覆盖将在未来的版本中弃用。 Bean 可以通过 id 或 name 属性进行命名，id 是唯一标识，name 是别名，支持多个别名，用逗号、分号或空格分隔。<br> 如果没有显式地提供 name 或 id，容器将为该 bean 生成一个唯一名称：取简单类名并将其首字母转换为小写；当有多个字符且第一和第二个字符都是大写时，会保留原始的大小写。<br> 在基于 XML 的配置元数据中，可以使用 <code>&lt;alias/&gt;</code> 元素为定义在其他地方的 bean 引入一个别名。<br> 如果你使用 Java 配置，可以使用 @Bean 注解来提供别名。<br> 虽然可以通过<code>getBean()</code>方法直接从IoC容器中获取Bean，但推荐使用依赖注入的方式，即通过构造器或setter方法注入依赖。</p><h3 id="bean生命周期" tabindex="-1"><a class="header-anchor" href="#bean生命周期"><span>Bean生命周期</span></a></h3><table><thead><tr><th>生命周期阶段</th><th>描述</th><th>方法</th><th>属性</th><th>注解</th></tr></thead><tbody><tr><td>实例化</td><td>初始化回调方法</td><td>setup</td><td>init-method</td><td>@PostConstruct</td></tr><tr><td>实例化</td><td>卸载前回调方法</td><td>teardown</td><td>destroy-method</td><td>@PreDestroy</td></tr></tbody></table><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入"><span>依赖注入</span></a></h2><h3 id="依赖注入方式" tabindex="-1"><a class="header-anchor" href="#依赖注入方式"><span>依赖注入方式</span></a></h3><p>依赖注入关注如何将依赖对象注入到目标 Bean 中，支持构造器注入、setter注入、字段注入三种方式：</p><ul><li>强制依赖使用<strong>构造器注入</strong>（Spring 4.3+可省略<code>@Autowired</code>）</li><li>可选依赖使用<strong>Setter注入</strong></li><li>避免使用<strong>字段注入</strong> 注：还有一种分类方式：构造器注入、接口注入、Setter注入。在现代依赖注入框架(如Spring)中，接口注入的使用已经不太常见。</li></ul><h3 id="自动装配" tabindex="-1"><a class="header-anchor" href="#自动装配"><span>自动装配</span></a></h3><p>自动装配是依赖注入的自动化实现形式，依赖注入是自动装配的设计目标。</p><h4 id="自动装配类型" tabindex="-1"><a class="header-anchor" href="#自动装配类型"><span>自动装配类型</span></a></h4><p>Spring支持四种自动装配类型：</p><ul><li>byName：通过参数名自动装配。</li><li>byType：通过参数类型自动装配，如果有多个bean符合条件，则抛出错误。</li><li>constructor：通过构造器参数类型自动装配，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li>autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><p>注：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。</p><h4 id="自动装配注解" tabindex="-1"><a class="header-anchor" href="#自动装配注解"><span>自动装配注解</span></a></h4><p>Spring支持的用于自动装配的注解：</p><ul><li>Spring自带的@Autowired注解 <ul><li>当有多个同类型Bean时，配合@Qualifier注解使用按名称装配</li><li>或者配合@Primary注解使用，指定首选Bean</li></ul></li><li>JSR-330的@Inject注解 <ul><li>当有多个同类型Bean时，配合@Named注解使用按名称装配</li></ul></li><li>JSR-250的@Resource注解 <ul><li>默认按名称装配，当找不到与名称匹配的bean才会按类型装配</li></ul></li></ul><p>强制依赖：依赖关系必须存在，若不存在，则会抛出异常。<br> 可选依赖：设置required=false表明配置是可选的，如果没有匹配的Bean，容器不会抛出异常。</p><table><thead><tr><th>注解</th><th>来源</th><th>使用范围</th><th>是否支持可选依赖</th><th>默认依赖注入方式</th><th>限定歧义性的依赖</th></tr></thead><tbody><tr><td>@Autowired</td><td>Spring</td><td>字段、构造器、方法</td><td>支持</td><td>类型</td><td>@Qualifier、@Primary</td></tr><tr><td>@Inject</td><td>JSR-330</td><td>字段、构造器、方法</td><td>不支持</td><td>类型</td><td>@Named</td></tr><tr><td>@Resource</td><td>JSR-250</td><td>字段、方法</td><td>不支持</td><td>名称-&gt;类型</td><td>通过name属性指定Bean名称</td></tr></tbody></table><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h2><h3 id="ioc-和-di-的区别" tabindex="-1"><a class="header-anchor" href="#ioc-和-di-的区别"><span>IoC 和 DI 的区别</span></a></h3><h3 id="ioc配置和依赖注入的关系" tabindex="-1"><a class="header-anchor" href="#ioc配置和依赖注入的关系"><span>Ioc配置和依赖注入的关系？</span></a></h3><p>Ioc配置关注如何定义和组装Bean，即告诉 Spring 容器如何管理对象及其依赖关系；依赖注入关注如何将依赖对象注入到目标 Bean 中。可以认为依赖注入是IoC配置的一部分，不同配置方式支持的注入方式不同：</p><ul><li>XML配置支持构造器注入和Setter注入方式</li><li>Java配置类通常使用构造器注入（<code>@Configuration</code>+<code>@Bean</code>+方法参数）</li><li>注解配置可以指定任一种注入方式（构造器/Setter/字段）</li></ul><h3 id="ioc-的实现机制" tabindex="-1"><a class="header-anchor" href="#ioc-的实现机制"><span>IoC 的实现机制</span></a></h3><p>工厂模式 + 反射机制</p>',48))])}const f=l(c,[["render",u]]),m=JSON.parse('{"path":"/posts/spring/spring-framework-ioc.html","title":"Spring核心 - IoC容器","lang":"zh-CN","frontmatter":{"title":"Spring核心 - IoC容器","date":"2025-05-08T08:49:38.561Z","category":["Spring","Spring Framework","IoC"],"tags":["Spring","Spring Framework","IoC"]},"git":{"updatedTime":1748588379000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"da5a302ca2c42f09f1ed2f26d6599d5b47380fc9","time":1748588379000,"email":"3036190149@qq.com","author":"zhaomy","message":"Spring Framework &#x26; Spring IoC"}]},"filePathRelative":"posts/spring/spring-framework-ioc.md","excerpt":"\\n\\n<h2>容器概述</h2>\\n<p><code>ApplicationContext</code> 接口代表 Spring IoC 容器，容器通过读取配置元数据获取指令来实例化、配置并组装 Bean。<br>\\nSpring 有两种IoC容器：<code>BeanFactory</code> 和 <code>ApplicationContext</code>。</p>\\n<ul>\\n<li>BeanFactory就像一个包含 Bean 集合的工厂类。</li>\\n<li>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。</li>\\n</ul>"}');export{f as comp,m as data};
