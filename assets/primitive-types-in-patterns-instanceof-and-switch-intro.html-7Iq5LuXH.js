import{_ as t,c as n,d as e,o as l}from"./app-BIl2daKx.js";const a={};function o(s,i){return l(),n("div",null,i[0]||(i[0]=[e('<p>通过允许在所有模式上下文中使用原始类型来增强模式匹配，并扩展 instanceof 和 switch 以使用所有原始类型。这是一个预览语言功能。</p><p>在所有模式上下文中允许<strong>原始类型模式与对应包装类型之间的宽松转换</strong>，并支持<strong>对记录组件的类型宽松匹配</strong>。核心贡献是：</p><ul><li>原始类型模式与应包装类型之间的宽松转换 <ul><li>增强 instanceof 和 switch 构造以支持原始类型模式作为顶级模式：允许在模式匹配中直接使用原始类型（如 <code>int p</code>）来匹配包装类（如 <code>Integer</code>）的对象。</li><li>增强记录模式以支持类型转换：允许在记录模式中使用原始类型来匹配包装类型的记录组件值，无需严格匹配包装类型。</li></ul></li><li>对记录组件的类型宽松匹配：在记录模式中使用原始类型来匹配记录的组件值时，无需严格匹配原始类型。这一机制支持在解构记录时自动完成原始类型的加宽转换和有条件的安全缩窄转换，显著提升了代码的简洁性与灵活性。</li><li>安全性 <ul><li>妥善处理 null 值，原始类型模式不会匹配 null，从而避免了潜在的 NullPointerException。</li><li>对于记录模式中可能造成信息丢失的缩窄转换（如 double → int），模式匹配会在运行时自动检查值的兼容性，仅在不丢失信息时完成匹配，否则返回 false，保障匹配过程的安全性与可靠性。</li></ul></li><li>语法与一致性更新：引入了相应的支配性检查规则，在同一个 switch 块中，原始类型模式（如 int i）和其对应的包装类型模式（如 Integer i）不能同时存在，因为它们会互相导致对方不可到达，无论顺序如何都会编译报错。记录模式也遵循相同的类型转换原则，进一步强化了模式匹配整体的语言一致性和表达力。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>模式 (Pattern)是一个通用概念，指的是在条件判断中同时进行类型检查和变量绑定的操作。例如：obj instanceof String s 就是一个类型模式，它同时检查 obj 是否是 String 类型，如果是，则将其绑定到变量 s。</p><p>instanceof 运算符是应用类型模式的第一个地方。从 Java 16 开始，instanceof 后面可以直接跟一个类型模式和变量名。</p><p>switch 表达式/语句是应用多种模式（包括类型模式、常量模式等）的更强大场所。在 Java 17 和 21 中，switch 的能力被大幅增强，case 标签可以支持模式。</p><p>所以三者关系是：模式匹配是一个范式；instanceof 和 switch 是应用该范式的语法工具。</p><p>因此，对JEP 488最准确的理解是：为模式、instanceof 和 switch 添加对原始类型的支持。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>自动加宽转换： 使用一个“较宽”的类型模式 (double) 去匹配一个“较窄”的组件类型 (int) 的值。编译器允许这种操作，并自动完成安全的值转换。</p><p>有条件的安全缩窄转换： 缩窄转换是一种可能丢失信息的转换（例如，将 double 3.14 转换为 int 3 会丢失小数部分），因此不是无条件进行的。</p><ul><li>JVM 会先检查这个 double 值是否能完全精确地转换为一个 int 值（即没有小数部分，且在 int 的取值范围内）</li><li>如果检查通过：模式匹配成功，变量被赋值</li><li>如果检查不通过（值太大或有小数）：模式匹配直接返回 false，不会赋值，也不会抛出异常</li></ul><p>注意：</p><ul><li>“自动加宽转换”和“有条件的安全缩窄转换”要求初始类型和目标类型都是原始类型。</li></ul></div>',5)]))}const r=t(a,[["render",o]]),p=JSON.parse('{"path":"/java/new-features/primitive-types-in-patterns-instanceof-and-switch-intro.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1758607541000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":2,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"45e9da4f9c89c3a73aba5fd1e310a07b0499f433","time":1758607541000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 新特性"},{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/primitive-types-in-patterns-instanceof-and-switch-intro.md","excerpt":"<p>通过允许在所有模式上下文中使用原始类型来增强模式匹配，并扩展 instanceof 和 switch 以使用所有原始类型。这是一个预览语言功能。</p>\\n<p>在所有模式上下文中允许<strong>原始类型模式与对应包装类型之间的宽松转换</strong>，并支持<strong>对记录组件的类型宽松匹配</strong>。核心贡献是：</p>\\n<ul>\\n<li>原始类型模式与应包装类型之间的宽松转换\\n<ul>\\n<li>增强 instanceof 和 switch 构造以支持原始类型模式作为顶级模式：允许在模式匹配中直接使用原始类型（如 <code>int p</code>）来匹配包装类（如 <code>Integer</code>）的对象。</li>\\n<li>增强记录模式以支持类型转换：允许在记录模式中使用原始类型来匹配包装类型的记录组件值，无需严格匹配包装类型。</li>\\n</ul>\\n</li>\\n<li>对记录组件的类型宽松匹配：在记录模式中使用原始类型来匹配记录的组件值时，无需严格匹配原始类型。这一机制支持在解构记录时自动完成原始类型的加宽转换和有条件的安全缩窄转换，显著提升了代码的简洁性与灵活性。</li>\\n<li>安全性\\n<ul>\\n<li>妥善处理 null 值，原始类型模式不会匹配 null，从而避免了潜在的 NullPointerException。</li>\\n<li>对于记录模式中可能造成信息丢失的缩窄转换（如 double → int），模式匹配会在运行时自动检查值的兼容性，仅在不丢失信息时完成匹配，否则返回 false，保障匹配过程的安全性与可靠性。</li>\\n</ul>\\n</li>\\n<li>语法与一致性更新：引入了相应的支配性检查规则，在同一个 switch 块中，原始类型模式（如 int i）和其对应的包装类型模式（如 Integer i）不能同时存在，因为它们会互相导致对方不可到达，无论顺序如何都会编译报错。记录模式也遵循相同的类型转换原则，进一步强化了模式匹配整体的语言一致性和表达力。</li>\\n</ul>"}');export{r as comp,p as data};
