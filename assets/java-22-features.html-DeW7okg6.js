import{_ as c,c as r,a,d as p,e as s,w as e,r as l,o as d,b as t}from"./app-BLwZODVo.js";const u={},h={class:"table-of-contents"};function m(v,n){const i=l("router-link"),o=l("RouteLink");return d(),r("div",null,[n[13]||(n[13]=a("h1",{id:"java-22-新特性",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#java-22-新特性"},[a("span",null,"Java 22 新特性")])],-1)),a("nav",h,[a("ul",null,[a("li",null,[s(i,{to:"#jep-423-g1-区域固定"},{default:e(()=>n[0]||(n[0]=[t("JEP 423: G1 区域固定")])),_:1,__:[0]})]),a("li",null,[s(i,{to:"#jep-447-super-前语句-预览"},{default:e(()=>n[1]||(n[1]=[t("JEP 447: super() 前语句（预览）")])),_:1,__:[1]})]),a("li",null,[s(i,{to:"#jep-454-外部函数与内存"},{default:e(()=>n[2]||(n[2]=[t("JEP 454: 外部函数与内存")])),_:1,__:[2]})]),a("li",null,[s(i,{to:"#jep-456-未命名变量和模式"},{default:e(()=>n[3]||(n[3]=[t("JEP 456: 未命名变量和模式")])),_:1,__:[3]})]),a("li",null,[s(i,{to:"#jep-457-类文件-api-预览"},{default:e(()=>n[4]||(n[4]=[t("JEP 457: 类文件 API（预览）")])),_:1,__:[4]})]),a("li",null,[s(i,{to:"#jep-458-启动多文件源代码程序"},{default:e(()=>n[5]||(n[5]=[t("JEP 458: 启动多文件源代码程序")])),_:1,__:[5]})]),a("li",null,[s(i,{to:"#jep-459-字符串模板-第二次预览"},{default:e(()=>n[6]||(n[6]=[t("JEP 459: 字符串模板（第二次预览）")])),_:1,__:[6]})]),a("li",null,[s(i,{to:"#jep-460-向量-api-第七次孵化"},{default:e(()=>n[7]||(n[7]=[t("JEP 460: 向量 API（第七次孵化）")])),_:1,__:[7]})]),a("li",null,[s(i,{to:"#jep-461-流收集器-预览"},{default:e(()=>n[8]||(n[8]=[t("JEP 461: 流收集器（预览）")])),_:1,__:[8]})]),a("li",null,[s(i,{to:"#jep-462-结构化并发-第二次预览"},{default:e(()=>n[9]||(n[9]=[t("JEP 462: 结构化并发（第二次预览）")])),_:1,__:[9]})]),a("li",null,[s(i,{to:"#jep-463-隐式声明的类和实例主方法-第二次预览"},{default:e(()=>n[10]||(n[10]=[t("JEP 463: 隐式声明的类和实例主方法（第二次预览）")])),_:1,__:[10]})]),a("li",null,[s(i,{to:"#jep-464-作用域值-第二次预览"},{default:e(()=>n[11]||(n[11]=[t("JEP 464: 作用域值（第二次预览）")])),_:1,__:[11]})])])]),n[14]||(n[14]=p(`<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Java 22 于 2024 年 3 月发布，包含了多个新特性和改进。</p></div><h2 id="jep-423-g1-区域固定" tabindex="-1"><a class="header-anchor" href="#jep-423-g1-区域固定"><span>JEP 423: G1 区域固定</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 423: Region Pinning for G1</p><p>Reduce latency by implementing region pinning in G1, so that garbage collection need not be disabled during Java Native Interface (JNI) critical regions.</p></div><p>在G1垃圾收集器中实现区域固定机制，从而避免在Java本地接口（JNI）关键区域执行期间暂停垃圾回收，以此降低系统延迟。</p><h2 id="jep-447-super-前语句-预览" tabindex="-1"><a class="header-anchor" href="#jep-447-super-前语句-预览"><span>JEP 447: super() 前语句（预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">Statements before super(...) (Preview)</p><p>In constructors in the Java programming language, allow statements that do not reference the instance being created to appear before an explicit constructor invocation. This is a preview language feature.</p></div><p>允许在构造函数中调用显示构造函数（super()、this()）之前执行不引用当前实例的语句，便于参数验证。</p><h2 id="jep-454-外部函数与内存" tabindex="-1"><a class="header-anchor" href="#jep-454-外部函数与内存"><span>JEP 454: 外部函数与内存</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 454: API Foreign Function &amp; Memory API</p><p>Introduce an API by which Java programs can interoperate with code and data outside of the Java runtime. By efficiently invoking foreign functions (i.e., code outside the JVM), and by safely accessing foreign memory (i.e., memory not managed by the JVM), the API enables Java programs to call native libraries and process native data without the brittleness and danger of JNI.</p></div><p>引入外部函数与内存API，使得Java程序能够与Java运行时之外的代码和数据交互。该API通过高效调用外部函数（即JVM之外的代码）及安全访问外部内存（即JVM不管理的内存），让Java程序能够调用本地库并处理本地数据，同时避免JNI存在的脆弱性和安全隐患。</p><p>提供安全、高效的方式来调用本地代码（如 C 库）和操作堆外内存，替代 JNI。</p><h2 id="jep-456-未命名变量和模式" tabindex="-1"><a class="header-anchor" href="#jep-456-未命名变量和模式"><span>JEP 456: 未命名变量和模式</span></a></h2><div class="hint-container info"><p class="hint-container-title">Unnamed Variables &amp; Patterns</p><p>Enhance the Java programming language with unnamed variables and unnamed patterns, which can be used when variable declarations or nested patterns are required but never used. Both are denoted by the underscore character, _.</p></div><p>支持使用下划线(_)表示未使用的模式和变量，简化代码并提高可读性。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"></span>
<span class="line"><span class="token comment">// 未命名变量</span></span>
<span class="line"><span class="token keyword">int</span> _ <span class="token operator">=</span> <span class="token function">calculateValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算但不使用结果</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 未命名模式</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> _<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 只检查类型，不关心具体值</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;It&#39;s a string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 在record模式中</span></span>
<span class="line"><span class="token keyword">record</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> _<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 只关心y坐标</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Y coordinate: &quot;</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jep-457-类文件-api-预览" tabindex="-1"><a class="header-anchor" href="#jep-457-类文件-api-预览"><span>JEP 457: 类文件 API（预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 457: Class-File API (Preview)</p><p>Provide a standard API for parsing, generating, and transforming Java class files. This is a preview API.</p></div><p>提供了一个用于解析、生成和转换 Java 类文件的标准 API，旨在替代第三方库（如 ASM）。</p><ul><li>解析（Parsing）：指的是读取一个已编译的<code>.class</code>文件，并将其内容（如魔数、版本号、常量池、方法、字段等）分解成程序可以理解和操作的结构化数据模型。</li><li>生成（Generation）：指的是从零开始，通过编程方式动态地创建出一个全新的、符合规范的<code>.class</code>文件。</li><li>转换（Transformation）：指的是读取一个现有的<code>.class</code>文件，对其结构进行修改（例如，添加/删除方法、修改字节码指令、植入分析代码等），然后输出修改后的新类文件。</li><li>标准 API（Standard API）：这是最关键的一点。这意味着该API是Java平台本身的一部分（例如在<code>java.lang.classfile</code>包下），由OpenJDK官方维护和发布。用户无需再引入额外的第三方JAR包。</li></ul><h2 id="jep-458-启动多文件源代码程序" tabindex="-1"><a class="header-anchor" href="#jep-458-启动多文件源代码程序"><span>JEP 458: 启动多文件源代码程序</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 458: Launch Multi-File Source-Code Programs</p><p>Enhance the java application launcher to be able to run a program supplied as multiple files of Java source code. This will make the transition from small programs to larger ones more gradual, enabling developers to choose whether and when to go to the trouble of configuring a build tool.</p></div><p>无需先编译，直接用 java 命令运行由多个 Java 源文件组成的程序。</p><h2 id="jep-459-字符串模板-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-459-字符串模板-第二次预览"><span>JEP 459: 字符串模板（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 459: String Templates (Second Preview)</p><p>Enhance the Java programming language with string templates. String templates complement Java&#39;s existing string literals and text blocks by coupling literal text with embedded expressions and template processors to produce specialized results. This is a preview language feature and API.</p></div><p>File not found</p><h2 id="jep-460-向量-api-第七次孵化" tabindex="-1"><a class="header-anchor" href="#jep-460-向量-api-第七次孵化"><span>JEP 460: 向量 API（第七次孵化）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 460: Vector API (Seventh Incubator)</p><p>Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations.</p></div><p>引入一个 API 来表达矢量计算，这些计算在运行时可靠地编译为受支持的 CPU 上的最佳矢量指令，从而实现优于等效标量计算的性能。</p><h2 id="jep-461-流收集器-预览" tabindex="-1"><a class="header-anchor" href="#jep-461-流收集器-预览"><span>JEP 461: 流收集器（预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>Stream Gatherers (Preview) Enhance the Stream API to support custom intermediate operations. This will allow stream pipelines to transform data in ways that are not easily achievable with the existing built-in intermediate operations. This is a preview API.</p></div><p>流收集器（Stream Gatherers）能为Stream API轻松添加自定义的中间操作，实现更复杂的数据转换。</p>`,31)),a("p",null,[s(o,{to:"/java/new-features/stream-gatherers-guide.html"},{default:e(()=>n[12]||(n[12]=[t("流收集器")])),_:1,__:[12]})]),n[15]||(n[15]=p(`<h2 id="jep-462-结构化并发-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-462-结构化并发-第二次预览"><span>JEP 462: 结构化并发（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 462: Structured Concurrency (Second Preview)</p><p>Simplify concurrent programming by introducing an API for structured concurrency. Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API.</p></div><p>通过引入结构化并发 API 来简化并发编程。结构化并发将不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。这是一个预览 API。</p><h2 id="jep-463-隐式声明的类和实例主方法-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-463-隐式声明的类和实例主方法-第二次预览"><span>JEP 463: 隐式声明的类和实例主方法（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview)</p><p>Evolve the Java programming language so that students can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of the language, students can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. This is a preview language feature.</p></div><p>扩展 Java 编程语言，使初学者无需了解专为大型程序设计的语言功能，即可编写自己的第一个程序。初学者无需使用某种独立的语言变体，即可为单类程序编写简化的声明，然后随着技能的增长无缝扩展他们的程序以使用更高级的功能。经验丰富的开发者同样可以简洁地编写小型程序，而不必使用那些为大规模编程设计的结构。</p><p>简单说就是省略显式类声明和 public static 修饰符，简化输出语句，来简化入门代码和脚本开发。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Java 23!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式调用 System.out.println</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改动点：将<strong>未命名类和实例主方法</strong>重命名为<strong>隐式声明的类和实例主方法</strong></p><h2 id="jep-464-作用域值-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-464-作用域值-第二次预览"><span>JEP 464: 作用域值（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 464: Scoped Values (Second Preview)</p><p>Introduce scoped values, which enable managed sharing of immutable data both with child frames in the same thread, and with child threads. Scoped values are easier to reason about than thread-local variables and have lower space and time costs, especially when used in combination with Virtual Threads and Structured Concurrency. This is a preview API.</p></div><p>引入作用域值（Scoped Values），支持在同一线程的子帧（child frames）及子线程间安全地共享不可变数据。与线程局部变量（thread-local variables）相比，作用域值更易于逻辑推演，并具有更低的空间和时间开销——尤其在与虚拟线程（Virtual Threads）和结构化并发（Structured Concurrency）结合使用时。该功能为预览版API。</p><p>用于在线程内和跨线程共享不可变数据，旨在替代 <code>ThreadLocal</code>，特别是在虚拟线程场景下更高效、更安全。</p><p>改动点：新增 runWhere 静态方法，支持同时设置多个值，更简洁直观。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"></span>
<span class="line"><span class="token comment">// 设置多个值</span></span>
<span class="line"><span class="token class-name">ScopedValue</span><span class="token punctuation">.</span><span class="token function">runWhere</span><span class="token punctuation">(</span><span class="token constant">USER_ID</span><span class="token punctuation">,</span> <span class="token string">&quot;user123&quot;</span><span class="token punctuation">,</span></span>
<span class="line">                    <span class="token constant">REQUEST_ID</span><span class="token punctuation">,</span> <span class="token string">&quot;req456&quot;</span><span class="token punctuation">,</span></span>
<span class="line">                    <span class="token constant">TIMEOUT</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span></span>
<span class="line">                    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 扁平化设计，更清晰</span></span>
<span class="line">  <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15))])}const f=c(u,[["render",m]]),k=JSON.parse('{"path":"/java/new-features/java-22-features.html","title":"Java 22 新特性","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1758607541000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":3,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"45e9da4f9c89c3a73aba5fd1e310a07b0499f433","time":1758607541000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 新特性"},{"hash":"18f0d4a4f1d4c588016a7d0c04145c1731b60fee","time":1757924168000,"email":"3036190149@qq.com","author":"zhaomy","message":"java22新特性 &#x26; java23-25新特性修改"},{"hash":"a56dd23708c5d2f36ccc4bf8fe2380b4e747453c","time":1757919595000,"email":"3036190149@qq.com","author":"zhaomy","message":"java24、java25新特性修改"}]},"filePathRelative":"java/new-features/java-22-features.md","excerpt":"\\n\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">相关信息</p>\\n<p>Java 22 于 2024 年 3 月发布，包含了多个新特性和改进。</p>\\n</div>\\n<h2>JEP 423: G1 区域固定</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">JEP 423: Region Pinning for G1</p>\\n<p>Reduce latency by implementing region pinning in G1, so that garbage collection need not be disabled during Java Native Interface (JNI) critical regions.</p>\\n</div>"}');export{f as comp,k as data};
