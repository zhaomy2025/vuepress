import{_ as n,c as e,d as s,o as t}from"./app-BLwZODVo.js";const o={};function l(i,a){return t(),e("div",null,a[0]||(a[0]=[s(`<h3 id="核心目标" tabindex="-1"><a class="header-anchor" href="#核心目标"><span>核心目标</span></a></h3><p>在保持Shenandoah原有的<strong>低暂停时间优势</strong>基础上，进一步<strong>减少内存占用和CPU开销</strong>。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><p>将堆内存划分为年轻代和老年代，优先且更频繁地收集年轻代（通常包含大量短生命周期对象），避免其过早晋升到老年代，减少全局垃圾回收的需要。</p><ul><li>新生代专用回收策略：采用复制篡法快速回收短生命周期对象，减少老年代扫描频率</li><li>卡表 (Card Table) 优化：精确记录老年代到新生代的跨代引用，降低 GC 停顿时间 30 ％以上</li><li>井行标记增强：在并发标记阶段优先处理新生代区域，使平均 GC 暂停时间控制在 2ms 以内。实测表明，在 16GB 堆内存的微服务场景下，分代 Shenandoah 相比原版吞吐量提升 40 ％，同时保持亚毫秒级的最大暂停时间，成为低延迟应用的理想选择。</li></ul><h3 id="启用方式" tabindex="-1"><a class="header-anchor" href="#启用方式"><span>启用方式</span></a></h3><p>需添加JVM参数：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UnlockExperimentalVMOptions</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">ShenandoahGCMode</span><span class="token operator">=</span>generational</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>低延迟高响应应用：例如实时交易系统、交互式数据分析平台。</li><li>大量短生命周期对象：例如处理大量临时请求或缓存数据的应用。</li><li>关注内存效率：希望降低垃圾收集器内存开销和CPU使用率的应用。</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><ul><li>Shenandoah GC最初在JDK 12中作为实验性功能引入，其最大特点是通过与应用程序线程并发执行大部分工作来尽可能减少GC暂停时间，且暂停时间与堆大小无关。</li><li>后在JDK 15中，Shenandoah GC从实验性功能转为正式的生产功能，不再需要额外的解锁实验参数，但其默认的垃圾收集器仍然是G1。</li><li>分代Shenandoah旨在与G1、ZGC（JEP 439已为ZGC引入分代模式）等现代收集器同步发展，同时保持自身在最小化延迟方面的独特优势。</li></ul></div>`,11)]))}const h=n(o,[["render",l]]),p=JSON.parse('{"path":"/java/new-features/generational-shenandoah-intro.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1757914089000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/generational-shenandoah-intro.md","excerpt":"<h3>核心目标</h3>\\n<p>在保持Shenandoah原有的<strong>低暂停时间优势</strong>基础上，进一步<strong>减少内存占用和CPU开销</strong>。</p>\\n<h3>工作原理</h3>\\n<p>将堆内存划分为年轻代和老年代，优先且更频繁地收集年轻代（通常包含大量短生命周期对象），避免其过早晋升到老年代，减少全局垃圾回收的需要。</p>\\n<ul>\\n<li>新生代专用回收策略：采用复制篡法快速回收短生命周期对象，减少老年代扫描频率</li>\\n<li>卡表 (Card Table) 优化：精确记录老年代到新生代的跨代引用，降低 GC 停顿时间 30 ％以上</li>\\n<li>井行标记增强：在并发标记阶段优先处理新生代区域，使平均 GC 暂停时间控制在 2ms 以内。实测表明，在 16GB 堆内存的微服务场景下，分代 Shenandoah 相比原版吞吐量提升 40 ％，同时保持亚毫秒级的最大暂停时间，成为低延迟应用的理想选择。</li>\\n</ul>"}');export{h as comp,p as data};
