import{_ as e,c as n,d as s,o as r}from"./app-DSgHH1tE.js";const t={};function i(o,a){return r(),n("div",null,a[0]||(a[0]=[s(`<h3 id="要解决的问题-java-启动后的-热身-阶段过慢" tabindex="-1"><a class="header-anchor" href="#要解决的问题-java-启动后的-热身-阶段过慢"><span>要解决的问题：Java 启动后的“热身”阶段过慢</span></a></h3><p>HotSpot JVM 刚启动时，所有字节码都运行在解释模式下，速度很慢。为了让热点方法（频繁调用的方法）达到最佳性能，JVM 必须经历以下阶段：</p><ol><li>解释执行 → 收集调用次数、分支频率等运行时剖析数据（profiling data）。</li><li>JIT 编译器 → 根据剖析数据生成高度优化的本地机器码。</li><li>替换执行 → 把解释执行切换到本地机器码，性能飙升。 这段“先解释、再编译、再切换”的时间就是常说的 warm-up（热身）时间 。 在大型应用里，warm-up 可能持续 数秒到数分钟 ，对云原生、Serverless、短生命周期任务极不友好。</li></ol><h3 id="jep-515-如何工作-直接复用上一次运行的剖析数据" tabindex="-1"><a class="header-anchor" href="#jep-515-如何工作-直接复用上一次运行的剖析数据"><span>JEP 515 如何工作：直接复用上一次运行的剖析数据</span></a></h3><p>JEP 515 的思路可以概括为一句话： “把上一次运行得到的剖析数据持久化到磁盘，下一次启动时直接加载。”</p><h3 id="如何启用" tabindex="-1"><a class="header-anchor" href="#如何启用"><span>如何启用</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+UseAOTMethodProfiles</span> <span class="token parameter variable">-XX:AOTProfilePath</span><span class="token operator">=</span>./myapp.prof <span class="token parameter variable">-jar</span> myapp.jar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>这项改进的本质是：将&quot;学习成本&quot;从运行时提前到构建时或第一次运行时，通过复用之前运行的经验来避免重复的学习过程。 就像一位经验丰富的司机： 传统方式：每次开车都要重新熟悉路况 新方式：使用之前的导航记录，一上路就知道最优路线</p>`,9)]))}const p=e(t,[["render",i]]),h=JSON.parse('{"path":"/java/new-features/ahead-of-time-method-profiling-intro.html","title":"","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1757914089000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/ahead-of-time-method-profiling-intro.md","excerpt":"<h3>要解决的问题：Java 启动后的“热身”阶段过慢</h3>\\n<p>HotSpot JVM 刚启动时，所有字节码都运行在解释模式下，速度很慢。为了让热点方法（频繁调用的方法）达到最佳性能，JVM 必须经历以下阶段：</p>\\n<ol>\\n<li>解释执行 → 收集调用次数、分支频率等运行时剖析数据（profiling data）。</li>\\n<li>JIT 编译器 → 根据剖析数据生成高度优化的本地机器码。</li>\\n<li>替换执行 → 把解释执行切换到本地机器码，性能飙升。\\n这段“先解释、再编译、再切换”的时间就是常说的 warm-up（热身）时间 。 在大型应用里，warm-up 可能持续 数秒到数分钟 ，对云原生、Serverless、短生命周期任务极不友好。</li>\\n</ol>"}');export{p as comp,h as data};
