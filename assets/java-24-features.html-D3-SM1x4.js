import{_ as u,c as h,a as n,d as l,e as t,w as s,b as e,r as d,o as m}from"./app-BLwZODVo.js";const v={},g={class:"table-of-contents"};function f(b,a){const i=d("router-link"),o=d("RouteLink"),c=d("CodeTabs");return m(),h("div",null,[a[50]||(a[50]=n("h1",{id:"java-24-新特性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#java-24-新特性"},[n("span",null,"Java 24 新特性")])],-1)),n("nav",g,[n("ul",null,[n("li",null,[t(i,{to:"#概述"},{default:s(()=>a[0]||(a[0]=[e("概述")])),_:1,__:[0]})]),n("li",null,[t(i,{to:"#jep-404-分代-shenandoah-实验性"},{default:s(()=>a[1]||(a[1]=[e("JEP 404: 分代 Shenandoah（实验性）")])),_:1,__:[1]}),n("ul",null,[n("li",null,[t(i,{to:"#核心目标"},{default:s(()=>a[2]||(a[2]=[e("核心目标")])),_:1,__:[2]})]),n("li",null,[t(i,{to:"#工作原理"},{default:s(()=>a[3]||(a[3]=[e("工作原理")])),_:1,__:[3]})]),n("li",null,[t(i,{to:"#启用方式"},{default:s(()=>a[4]||(a[4]=[e("启用方式")])),_:1,__:[4]})]),n("li",null,[t(i,{to:"#适用场景"},{default:s(()=>a[5]||(a[5]=[e("适用场景")])),_:1,__:[5]})])])]),n("li",null,[t(i,{to:"#jep-450-紧凑对象头-实验性"},{default:s(()=>a[6]||(a[6]=[e("JEP 450: 紧凑对象头（实验性）")])),_:1,__:[6]}),n("ul",null,[n("li",null,[t(i,{to:"#核心原理"},{default:s(()=>a[7]||(a[7]=[e("核心原理")])),_:1,__:[7]})]),n("li",null,[t(i,{to:"#新旧对象头布局对比"},{default:s(()=>a[8]||(a[8]=[e("新旧对象头布局对比")])),_:1,__:[8]})]),n("li",null,[t(i,{to:"#启用方式-1"},{default:s(()=>a[9]||(a[9]=[e("启用方式")])),_:1,__:[9]})]),n("li",null,[t(i,{to:"#适用场景-1"},{default:s(()=>a[10]||(a[10]=[e("适用场景")])),_:1,__:[10]})])])]),n("li",null,[t(i,{to:"#jep-472-准备限制-jni-的使用"},{default:s(()=>a[11]||(a[11]=[e("JEP 472: 准备限制 JNI 的使用")])),_:1,__:[11]}),n("ul",null,[n("li",null,[t(i,{to:"#核心目标-1"},{default:s(()=>a[12]||(a[12]=[e("核心目标")])),_:1,__:[12]})]),n("li",null,[t(i,{to:"#动机与背景"},{default:s(()=>a[13]||(a[13]=[e("动机与背景")])),_:1,__:[13]})]),n("li",null,[t(i,{to:"#核心变化"},{default:s(()=>a[14]||(a[14]=[e("核心变化")])),_:1,__:[14]})]),n("li",null,[t(i,{to:"#未来计划"},{default:s(()=>a[15]||(a[15]=[e("未来计划")])),_:1,__:[15]})]),n("li",null,[t(i,{to:"#重要说明"},{default:s(()=>a[16]||(a[16]=[e("重要说明")])),_:1,__:[16]})]),n("li",null,[t(i,{to:"#总结"},{default:s(()=>a[17]||(a[17]=[e("总结")])),_:1,__:[17]})])])]),n("li",null,[t(i,{to:"#jep-475-g1-的-late-barrier-扩展"},{default:s(()=>a[18]||(a[18]=[e("JEP 475: G1 的 Late Barrier 扩展")])),_:1,__:[18]})]),n("li",null,[t(i,{to:"#jep-478-密钥派生函数-api-预览"},{default:s(()=>a[19]||(a[19]=[e("JEP 478: 密钥派生函数 API（预览）")])),_:1,__:[19]})]),n("li",null,[t(i,{to:"#jep-479-删除-windows-32-位-x86-端口"},{default:s(()=>a[20]||(a[20]=[e("JEP 479: 删除 Windows 32 位 x86 端口")])),_:1,__:[20]})]),n("li",null,[t(i,{to:"#jep-483-提前类加载和链接"},{default:s(()=>a[21]||(a[21]=[e("JEP 483: 提前类加载和链接")])),_:1,__:[21]})]),n("li",null,[t(i,{to:"#jep-484-类文件-api"},{default:s(()=>a[22]||(a[22]=[e("JEP 484: 类文件 API")])),_:1,__:[22]})]),n("li",null,[t(i,{to:"#jep-485-流收集器"},{default:s(()=>a[23]||(a[23]=[e("JEP 485: 流收集器")])),_:1,__:[23]})]),n("li",null,[t(i,{to:"#jep-486-永久禁用安全管理器"},{default:s(()=>a[24]||(a[24]=[e("JEP 486: 永久禁用安全管理器")])),_:1,__:[24]})]),n("li",null,[t(i,{to:"#jep-487-作用域值-第四次预览"},{default:s(()=>a[25]||(a[25]=[e("JEP 487: 作用域值（第四次预览）")])),_:1,__:[25]})]),n("li",null,[t(i,{to:"#jep-488-模式、instanceof-和-switch中的原始类型-第二次预览"},{default:s(()=>a[26]||(a[26]=[e("JEP 488: 模式、instanceof 和 switch中的原始类型（第二次预览）")])),_:1,__:[26]})]),n("li",null,[t(i,{to:"#jep-489-向量-api-第九个孵化器"},{default:s(()=>a[27]||(a[27]=[e("JEP 489: 向量 API（第九个孵化器）")])),_:1,__:[27]})]),n("li",null,[t(i,{to:"#jep-490-zgc-删除非分代模式"},{default:s(()=>a[28]||(a[28]=[e("JEP 490: ZGC：删除非分代模式")])),_:1,__:[28]})]),n("li",null,[t(i,{to:"#jep-491-无需固定即可同步虚拟线程"},{default:s(()=>a[29]||(a[29]=[e("JEP 491: 无需固定即可同步虚拟线程")])),_:1,__:[29]})]),n("li",null,[t(i,{to:"#jep-492-灵活的构造函数体-第三次预览"},{default:s(()=>a[30]||(a[30]=[e("JEP 492: 灵活的构造函数体（第三次预览）")])),_:1,__:[30]})]),n("li",null,[t(i,{to:"#jep-493-无需-jmod-即可链接运行时图像"},{default:s(()=>a[31]||(a[31]=[e("JEP 493: 无需 JMOD 即可链接运行时图像")])),_:1,__:[31]})]),n("li",null,[t(i,{to:"#jep-494-模块导入声明-第二次预览"},{default:s(()=>a[32]||(a[32]=[e("JEP 494: 模块导入声明（第二次预览）")])),_:1,__:[32]})]),n("li",null,[t(i,{to:"#jep-495-简单源文件和实例主方法-第四次预览"},{default:s(()=>a[33]||(a[33]=[e("JEP 495: 简单源文件和实例主方法（第四次预览）")])),_:1,__:[33]})]),n("li",null,[t(i,{to:"#jep-496-基于抗量子模块格的密钥封装机制"},{default:s(()=>a[34]||(a[34]=[e("JEP 496: 基于抗量子模块格的密钥封装机制")])),_:1,__:[34]})]),n("li",null,[t(i,{to:"#jep-497-基于模块格的抗量子数字签名算法"},{default:s(()=>a[35]||(a[35]=[e("JEP 497: 基于模块格的抗量子数字签名算法")])),_:1,__:[35]})]),n("li",null,[t(i,{to:"#jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告"},{default:s(()=>a[36]||(a[36]=[e("JEP 498: 在 sun.misc.Unsafe 中使用内存访问方法时发出警告")])),_:1,__:[36]})]),n("li",null,[t(i,{to:"#jep-499-结构化并发-第四次预览"},{default:s(()=>a[37]||(a[37]=[e("JEP 499: 结构化并发（第四次预览）")])),_:1,__:[37]})]),n("li",null,[t(i,{to:"#jep-501-弃用-32-位-x86-端口并将其删除"},{default:s(()=>a[38]||(a[38]=[e("JEP 501: 弃用 32 位 x86 端口并将其删除")])),_:1,__:[38]})]),n("li",null,[t(i,{to:"#参考资料"},{default:s(()=>a[39]||(a[39]=[e("参考资料")])),_:1,__:[39]})])])]),a[51]||(a[51]=l(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>Java 24 于 2025 年 3 月发布，该版本提供24项新特性（含10项孵化/预览/实验功能）</p><h2 id="jep-404-分代-shenandoah-实验性" tabindex="-1"><a class="header-anchor" href="#jep-404-分代-shenandoah-实验性"><span>JEP 404: 分代 Shenandoah（实验性）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 404: Generational Shenandoah (Experimental)</p><p>Enhance the Shenandoah garbage collector with experimental generational collection capabilities to improve sustainable throughput, load-spike resilience, and memory utilization.</p></div><p>通过实验性分代收集功能增强 Shenandoah 垃圾回收器，以提高可持续吞吐量、负载峰值弹性和内存利用率。</p><h3 id="核心目标" tabindex="-1"><a class="header-anchor" href="#核心目标"><span>核心目标</span></a></h3><p>在保持Shenandoah原有的<strong>低暂停时间优势</strong>基础上，进一步<strong>减少内存占用和CPU开销</strong>。</p><h3 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h3><p>将堆内存划分为年轻代和老年代，优先且更频繁地收集年轻代（通常包含大量短生命周期对象），避免其过早晋升到老年代，减少全局垃圾回收的需要。</p><ul><li>新生代专用回收策略：采用复制篡法快速回收短生命周期对象，减少老年代扫描频率</li><li>卡表 (Card Table) 优化：精确记录老年代到新生代的跨代引用，降低 GC 停顿时间 30 ％以上</li><li>井行标记增强：在并发标记阶段优先处理新生代区域，使平均 GC 暂停时间控制在 2ms 以内。实测表明，在 16GB 堆内存的微服务场景下，分代 Shenandoah 相比原版吞吐量提升 40 ％，同时保持亚毫秒级的最大暂停时间，成为低延迟应用的理想选择。</li></ul><h3 id="启用方式" tabindex="-1"><a class="header-anchor" href="#启用方式"><span>启用方式</span></a></h3><p>需添加JVM参数：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">UnlockExperimentalVMOptions</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">ShenandoahGCMode</span><span class="token operator">=</span>generational</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h3><ul><li>低延迟高响应应用：例如实时交易系统、交互式数据分析平台。</li><li>大量短生命周期对象：例如处理大量临时请求或缓存数据的应用。</li><li>关注内存效率：希望降低垃圾收集器内存开销和CPU使用率的应用。</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><ul><li>Shenandoah GC最初在JDK 12中作为实验性功能引入，其最大特点是通过与应用程序线程并发执行大部分工作来尽可能减少GC暂停时间，且暂停时间与堆大小无关。</li><li>后在JDK 15中，Shenandoah GC从实验性功能转为正式的生产功能，不再需要额外的解锁实验参数，但其默认的垃圾收集器仍然是G1。</li><li>分代Shenandoah旨在与G1、ZGC（JEP 439已为ZGC引入分代模式）等现代收集器同步发展，同时保持自身在最小化延迟方面的独特优势。</li></ul></div><h2 id="jep-450-紧凑对象头-实验性" tabindex="-1"><a class="header-anchor" href="#jep-450-紧凑对象头-实验性"><span>JEP 450: 紧凑对象头（实验性）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 450: Compact Object Headers (Experimental)</p><p>Reduce the size of object headers in the HotSpot JVM from between 96 and 128 bits down to 64 bits on 64-bit architectures. This will reduce heap size, improve deployment density, and increase data locality.</p></div><p>重构了Java对象的内存布局，将 HotSpot JVM 中的普通对象头大小从96到128位减少到64位，从而提升内存利用率和应用性能。</p><h3 id="核心原理" tabindex="-1"><a class="header-anchor" href="#核心原理"><span>核心原理</span></a></h3><p>Java 对象在堆中的存储包含<strong>对象头</strong>和<strong>实例数据</strong>。对象头又分为：</p><ul><li><strong>标记字 (Mark Word)</strong>：存储哈希码、GC 年龄、锁状态、线程持有的锁、偏向线程ID、偏向时间戳等运行时数据。</li><li><strong>类指针 (Class Pointer)</strong>：指向对象的类元数据。</li><li><strong>数组长度</strong>：数组对象的头部还会额外包含该字段。</li></ul><p>在 64 位 JVM 中，普通对象头通常占 <strong>12字节（96位） 至 16字节（128位）</strong>。对于许多平均大小仅为 32-64 字节的小对象来说，对象头的开销占比非常高，可能达到 <strong>20% 到 50%</strong>。JEP 450 通过以下方式将对象头压缩至 <strong>64 位 (8 字节)</strong>：</p><ul><li><strong>压缩类指针</strong>：将原本 32 位的压缩类指针进一步优化为 <strong>22 位</strong>，并将其编码嵌入标记字中。</li><li><strong>标记字的功能重组与升级</strong>：对固定的 64 位标记字空间进行了彻底的重新规划，将其划分为一个精细的功能位域集合，以同时承载原有和新增的信息</li><li><strong>锁机制革新</strong>：传统的<strong>偏向锁</strong> 和<strong>轻量级锁</strong> 会覆盖整个标记字（除锁标记位外），与紧凑对象头中必须保留类指针的设计冲突。因此，<strong>紧凑对象头不再支持偏向锁和栈锁</strong>。它依赖 <strong>JDK 22 中引入的对象监视表</strong> 来管理重量级锁信息。</li></ul><h3 id="新旧对象头布局对比" tabindex="-1"><a class="header-anchor" href="#新旧对象头布局对比"><span>新旧对象头布局对比</span></a></h3><p>为了更直观地理解其变化，可以参考下表对传统对象头与紧凑对象头进行的对比：</p><h4 id="java传统对象头" tabindex="-1"><a class="header-anchor" href="#java传统对象头"><span>Java传统对象头</span></a></h4><p><strong>传统对象头大小</strong></p><table><thead><tr><th style="text-align:left;">是否压缩</th><th style="text-align:left;">对象类型</th><th style="text-align:left;">大小</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">压缩</td><td style="text-align:left;">普通对象</td><td style="text-align:left;">12字节（96位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针4B（32位）</td></tr><tr><td style="text-align:left;">压缩</td><td style="text-align:left;">数组对象</td><td style="text-align:left;">16字节（128位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针4B（32位）<br>+ 数组长度4B（32位）</td></tr><tr><td style="text-align:left;">未压缩</td><td style="text-align:left;">普通对象</td><td style="text-align:left;">16字节（128位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针8B（64位）</td></tr><tr><td style="text-align:left;">未压缩</td><td style="text-align:left;">数组对象</td><td style="text-align:left;">20字节（160位）</td><td style="text-align:left;">标记字8B（64位）+ 类指针8B（64位）<br>+ 数组长度4B（32位）</td></tr></tbody></table><p><strong>传统对象头标记字（Mark Word）</strong></p><table><thead><tr><th>状态</th><th>锁状态</th><th>偏向锁</th><th>GC分代<br>年龄</th><th>未使用</th><th>其他</th></tr></thead><tbody><tr><td>无锁状态</td><td>01</td><td>0</td><td>4位</td><td>1位</td><td>哈希码（31位）+ 未使用（25位）</td></tr><tr><td>偏向锁状态</td><td>01</td><td>1</td><td>4位</td><td>1位</td><td>线程ID（54位）+ epoch（2位）</td></tr><tr><td>轻量级锁状态</td><td>00</td><td colspan="4">指向锁记录的指针（62位）</td></tr><tr><td>重量级锁状态</td><td>10</td><td colspan="4">指向Monitor的指针（62位）</td></tr><tr><td>GC 分代年龄</td><td>11</td><td colspan="4">GC所需标记信息</td></tr></tbody></table><h4 id="紧凑对象头" tabindex="-1"><a class="header-anchor" href="#紧凑对象头"><span>紧凑对象头</span></a></h4><table><thead><tr><th style="text-align:left;">标记位</th><th style="text-align:left;">自转发标记位</th><th style="text-align:left;">GC分代年龄</th><th style="text-align:left;">预留</th><th style="text-align:left;">哈希码</th><th style="text-align:left;">压缩类指针</th></tr></thead><tbody><tr><td style="text-align:left;">2位</td><td style="text-align:left;">1位</td><td style="text-align:left;">4位</td><td style="text-align:left;">4位</td><td style="text-align:left;">31位</td><td style="text-align:left;">22位</td></tr></tbody></table><h3 id="启用方式-1" tabindex="-1"><a class="header-anchor" href="#启用方式-1"><span>启用方式</span></a></h3><p>Java 24 中，紧凑对象头是实验性功能，需要特定 JVM 参数启用，Java 25 成为正式功能，无需手动启动。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token parameter variable">-XX:+UnlockExperimentalVMOptions</span> <span class="token parameter variable">-XX:+UseCompactObjectHeaders</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="适用场景-1" tabindex="-1"><a class="header-anchor" href="#适用场景-1"><span>适用场景</span></a></h3><p>紧凑对象头尤其适用于以下场景：</p><ul><li><strong>大量小对象</strong>的应用（如微服务、DTO、缓存元素）。</li><li><strong>内存敏感型</strong>工作负载（希望降低内存占用和提高部署密度）。</li><li><strong>关注缓存效率和高吞吐量</strong>的应用。</li></ul><p>在决定是否启用时，需考虑：</p><ul><li><strong>应用程序特性</strong>：若应用严重依赖偏向锁，需评估其影响。</li><li><strong>GC 选择</strong>：目前该特性主要支持 G1 和 Parallel GC。对于 ZGC 的支持尚未完成。</li><li><strong>类加载数量</strong>：确保应用加载的类数量远低于 400 万的上限。</li></ul><h2 id="jep-472-准备限制-jni-的使用" tabindex="-1"><a class="header-anchor" href="#jep-472-准备限制-jni-的使用"><span>JEP 472: 准备限制 JNI 的使用</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 472: Prepare to Restrict the Use of JNI</p><p>Issue warnings about uses of the Java Native Interface (JNI) and adjust the Foreign Function &amp; Memory (FFM) API to issue warnings in a consistent manner. All such warnings aim to prepare developers for a future release that ensures integrity by default by uniformly restricting JNI and the FFM API. Application developers can avoid both current warnings and future restrictions by selectively enabling these interfaces where essential.</p></div><p>JEP 472（Prepare to Restrict the Use of JNI）是JDK 24中的一个重要提案，旨在<strong>增强Java平台的安全性</strong>，通过引入对Java本地接口（JNI）使用的限制和警告，为未来版本默认禁止通过JNI或FFM API与本地代码互操作做准备。</p><h3 id="核心目标-1" tabindex="-1"><a class="header-anchor" href="#核心目标-1"><span>核心目标</span></a></h3><p>JEP 472的主要目标包括：</p><ul><li>保持JNI地位：继续保持JNI作为与本地代码互操作的标准方式的地位。</li><li>准备生态系统：准备Java生态系统迎接未来的版本，默认不允许通过JNI或FFM API与本地代码互操作。自该版本起，应用程序开发者必须在启动时显式启用JNI和FFM API的使用。</li><li>统一使用方式：统一JNI和FFM API的使用方式，使库维护者可以在两者之间迁移而无需应用程序开发者更改任何命令行选项。</li></ul><h3 id="动机与背景" tabindex="-1"><a class="header-anchor" href="#动机与背景"><span>动机与背景</span></a></h3><p>JNI自JDK 1.1引入以来，一直是Java代码与本地代码（通常用C/C++编写）互操作的主要手段。但它也带来了显著的安全风险：</p><ul><li>未定义行为与崩溃：调用本地代码可能导致任意的未定义行为，包括JVM崩溃，且Java运行时无法阻止此类问题，也无法抛出可捕获的异常。</li><li>内存安全风险：本地代码和Java代码经常通过直接字节缓冲区交换数据，这些区域不受JVM垃圾收集器管理。本地代码可能生成由无效内存区域支持的字节缓冲区，在Java代码中使用会引发未定义行为。</li><li>绕过访问检查：本地代码可以使用JNI访问字段和调用方法，而不经过JVM的任何访问检查，甚至可以改变<code>final</code>字段的值，从而破坏其他Java代码的一致性。</li><li>不良GC行为：不正确使用某些JNI函数（如<code>GetPrimitiveArrayCritical</code>和<code>GetStringCritical</code>）可能导致不良的垃圾回收行为。</li></ul><p>JDK 22引入的外部函数与内存（FFM）API作为JNI的现代替代方案，虽然也面临类似风险，但其设计通过“受限方法”和要求开发者显式选择加入来缓解风险。JEP 472旨在使JNI遵循类似的安全范式，这是确保Java平台默认一致性（默认安全）的长期努力的一部分，其他相关举措包括移除<code>sun.misc.Unsafe</code>中的内存访问方法（JEP 471）和限制动态加载代理（JEP 451）。</p><h3 id="核心变化" tabindex="-1"><a class="header-anchor" href="#核心变化"><span>核心变化</span></a></h3><p>JEP 472的核心变化在于对JNI的“加载和链接本地库”操作施加本地访问限制（Native Access Restrictions），并与FFM API保持一致。</p><ul><li><p>受限操作：在JDK 24中，以下操作将默认触发警告（未来版本将抛出异常）：</p><ul><li>调用<code>System::loadLibrary</code>, <code>System::load</code>, <code>Runtime::loadLibrary</code>或<code>Runtime::load</code>。</li><li>声明<code>native</code>方法。</li></ul></li><li><p>启用本地访问：应用程序开发者必须显式启用本地访问以避免警告和未来的异常。这可以通过以下方式实现：</p><ul><li>命令行选项：<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token comment"># 为类路径上的所有代码启用</span></span>
<span class="line"><span class="token function">java</span> --enable-native-access<span class="token operator">=</span>ALL-UNNAMED <span class="token parameter variable">-jar</span> your_app.jar</span>
<span class="line"><span class="token comment"># 为模块路径上的特定模块启用</span></span>
<span class="line"><span class="token function">java</span> --enable-native-access<span class="token operator">=</span>MODULE1,MODULE2 <span class="token parameter variable">-jar</span> your_app.jar</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>参数文件：在 <code>config-file</code> 中写入 <code>--enable-native-access=ALL-UNNAMED</code>，然后运行 <code>java @config-file -jar myapp.jar</code></li><li>环境变量传递：<code>export JDK_JAVA_OPTIONS=&quot;--enable-native-access=ALL-UNNAMED&quot;</code>，然后运行<code>java -jar myapp.jar</code></li><li>JAR清单属性：在可执行JAR的清单中添加<code>Enable-Native-Access: ALL-UNNAMED</code>。</li><li>其他方式：如通过<code>jlink</code>定制运行时镜像时添加选项，或使用<code>ModuleLayer.Controller::enableNativeAccess</code>方法（其本身是受限方法）。</li></ul></li><li><p>控制限制效果：新的命令行选项<code>--illegal-native-access</code>用于控制违反限制时的行为：</p><ul><li><code>warn</code>（JDK 24默认）：允许操作但发出警告（每个模块最多一次）。</li><li><code>deny</code>：抛出<code>IllegalCallerException</code>（未来版本的默认行为）。</li><li><code>allow</code>：允许操作继续（未来版本会移除）。</li></ul></li></ul><h3 id="未来计划" tabindex="-1"><a class="header-anchor" href="#未来计划"><span>未来计划</span></a></h3><p>JEP 472是分阶段实施的长期计划的一部分：</p><ul><li>JDK 24：默认行为是<code>--illegal-native-access=warn</code>，即发出警告。</li><li>未来JDK版本：默认行为将变为<code>--illegal-native-access=deny</code>，即抛出异常，最终实现默认一致性。</li></ul><h3 id="重要说明" tabindex="-1"><a class="header-anchor" href="#重要说明"><span>重要说明</span></a></h3><ul><li>不弃用JNI：JEP 472并非要弃用或移除JNI，也不是要限制本地代码本身的行为。所有本地JNI函数仍然可供本地代码使用。</li><li>影响范围：此限制主要影响加载本地库和链接native方法的Java代码。仅调用其他模块中声明的<code>native</code>方法的代码本身不需要启用本地访问。</li><li>FFM API对齐：JNI和FFM API在本地访问限制上保持一致，简化了库的迁移和应用程序的配置。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>JEP 472是Java迈向“默认安全” 的重要一步。它通过引入对JNI使用的限制和警告，促使开发者更显式地管理本地代码访问，从而提升应用程序和Java平台整体的安全性和完整性。</p><p>虽然这增加了些许配置成本，但为构建更安全可靠的Java生态系统奠定了基础。对于开发者来说，关键是检查现有代码并适时添加<code>--enable-native-access</code>标志。</p><h2 id="jep-475-g1-的-late-barrier-扩展" tabindex="-1"><a class="header-anchor" href="#jep-475-g1-的-late-barrier-扩展"><span>JEP 475: G1 的 Late Barrier 扩展</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 475: Late Barrier Expansion for G1</p><p>Simplify the implementation of the G1 garbage collector&#39;s barriers, which record information about application memory accesses, by shifting their expansion from early in the C2 JIT&#39;s compilation pipeline to later.</p></div><p>通过将G1垃圾回收器屏障的生成时机，从C2 JIT编译前期移至后期，简化了其实现。这些屏障的作用是记录有关应用程序内存访问的信息。</p><h2 id="jep-478-密钥派生函数-api-预览" tabindex="-1"><a class="header-anchor" href="#jep-478-密钥派生函数-api-预览"><span>JEP 478: 密钥派生函数 API（预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 478: Key Derivation Function API (Preview)</p><p>Introduce an API for Key Derivation Functions (KDFs), which are cryptographic algorithms for deriving additional keys from a secret key and other data. This is a preview API.</p></div><p>引入一个用于密钥派生函数的预览版API。密钥派生函数是一种可从密钥及其他数据中推导出更多密钥的密码学算法。</p><p><strong>目标</strong>：</p><ul><li>使应用程序能够使用KDF算法，例如基于HMAC的提取-扩展密钥派生函数（HKDF，RFC 5869）和Argon2（RFC 9106）。</li><li>支持在密钥封装机制（KEM，JEP 452）实现（如ML-KEM）、高层协议（如TLS 1.3中的混合密钥交换）以及密码方案（如混合公钥加密HPKE，RFC 9180）中使用KDF。</li><li>允许安全提供商使用Java代码或原生代码来实现KDF算法。</li><li>包含了HKDF的一个实现，并引入了额外的HKDF专用API。</li></ul><h2 id="jep-479-删除-windows-32-位-x86-端口" tabindex="-1"><a class="header-anchor" href="#jep-479-删除-windows-32-位-x86-端口"><span>JEP 479: 删除 Windows 32 位 x86 端口</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 479: Remove the Windows 32-bit x86 Port</p><p>Remove the source code and build support for the Windows 32-bit x86 port. This port was deprecated for removal in JDK 21 with the express intent to remove it in a future release.</p></div><p>移除针对 Windows 32 位 x86 端口的源代码和构建支持。该端口已在 JDK 21 中被标记为弃用并计划移除，并明确表达了在未来的版本中将其移除的意图。</p><h2 id="jep-483-提前类加载和链接" tabindex="-1"><a class="header-anchor" href="#jep-483-提前类加载和链接"><span>JEP 483: 提前类加载和链接</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 483: Ahead-of-Time Class Loading &amp; Linking</p><p>Improve startup time by making the classes of an application instantly available, in a loaded and linked state, when the HotSpot Java Virtual Machine starts.Achieve this by monitoring the application during one run and storing the loaded and linked forms of all classes in a cache for use in subsequent runs. Lay a foundation for future improvements to both startup and warmup time.</p></div><p>通过让应用程序的类在 HotSpot Java 虚拟机启动时就能立即可用（即已完成加载和链接），来提升启动速度。 其实现方式是：在应用的一次运行期间进行监控，并将所有类的加载和链接形式存储在缓存中以供后续运行使用。 这同时也为未来优化启动与预热时间打下了基础。</p><h2 id="jep-484-类文件-api" tabindex="-1"><a class="header-anchor" href="#jep-484-类文件-api"><span>JEP 484: 类文件 API</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 484: Class-File API</p><p>Provide a standard API for parsing, generating, and transforming Java class files.</p></div><p>提供了一个用于解析、生成和转换 Java 类文件的标准 API，旨在替代第三方库（如 ASM）。</p><ul><li>解析（Parsing）：指的是读取一个已编译的<code>.class</code>文件，并将其内容（如魔数、版本号、常量池、方法、字段等）分解成程序可以理解和操作的结构化数据模型。</li><li>生成（Generation）：指的是从零开始，通过编程方式动态地创建出一个全新的、符合规范的<code>.class</code>文件。</li><li>转换（Transformation）：指的是读取一个现有的<code>.class</code>文件，对其结构进行修改（例如，添加/删除方法、修改字节码指令、植入分析代码等），然后输出修改后的新类文件。</li><li>标准 API（Standard API）：这是最关键的一点。这意味着该API是Java平台本身的一部分（例如在<code>java.lang.classfile</code>包下），由OpenJDK官方维护和发布。用户无需再引入额外的第三方JAR包。</li></ul><p>自第二个预览版以来的更改包括重命名枚举值、删除某些字段、添加方法和方法重载、重命名方法以及删除被认为不必要的接口和方法。</p><h2 id="jep-485-流收集器" tabindex="-1"><a class="header-anchor" href="#jep-485-流收集器"><span>JEP 485: 流收集器</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 485: Stream Gatherers</p><p>Enhance the Stream API to support custom intermediate operations. This will allow stream pipelines to transform data in ways that are not easily achievable with the existing built-in intermediate operations.</p></div><p>流收集器（Stream Gatherers）能为Stream API轻松添加自定义的中间操作，实现更复杂的数据转换。</p>`,84)),n("p",null,[t(o,{to:"/java/new-features/stream-gatherers-guide.html"},{default:s(()=>a[40]||(a[40]=[e("流收集器")])),_:1,__:[40]})]),a[52]||(a[52]=l('<h2 id="jep-486-永久禁用安全管理器" tabindex="-1"><a class="header-anchor" href="#jep-486-永久禁用安全管理器"><span>JEP 486: 永久禁用安全管理器</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 486: Permanently Disable the Security Manager</p><p>The Security Manager has not been the primary means of securing client-side Java code for many years, it has rarely been used to secure server-side code, and it is costly to maintain. We therefore deprecated it for removal in Java 17 via JEP 411 (2021). As the next step toward removing the Security Manager, we will revise the Java Platform specification so that developers cannot enable it and other Platform classes do not refer to it. This change will have no impact on the vast majority of applications, libraries, and tools. We will remove the Security Manager API in a future release.</p></div><p>安全管理器早已不是保护客户端Java代码的主要手段，在服务端代码中也鲜有应用，且维护成本高昂。因此，该机制已于2021年通过JEP 411在Java 17中被标记为弃用并计划移除。作为移除工作的下一步，Java平台规范将进行修订，使开发者无法启用该功能，并确保其他平台类不再引用它。此项变更对绝大多数应用程序、库和工具不会产生任何影响。Security Manager API将在未来版本中被彻底移除。</p><h2 id="jep-487-作用域值-第四次预览" tabindex="-1"><a class="header-anchor" href="#jep-487-作用域值-第四次预览"><span>JEP 487: 作用域值（第四次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 487: Scoped Values (Fourth Preview)</p><p>Introduce scoped values, which enable a method to share immutable data both with its callees within a thread, and with child threads. Scoped values are easier to reason about than thread-local variables. They also have lower space and time costs, especially when used together with virtual threads (JEP 444) and structured concurrency (JEP 480). This is a preview API.</p></div><p>引入作用域值，使方法能够与线程中的被调用方以及子线程共享不可变数据。作用域值比线程局部变量更容易推理。它们还具有较低的空间和时间成本，特别是当与虚拟线程（JEP 444）和结构化并发（JEP 505）一起使用时。</p>',6)),n("p",null,[t(o,{to:"/java/new-features/scoped-values-guide.html"},{default:s(()=>a[41]||(a[41]=[e("作用域值")])),_:1,__:[41]})]),a[53]||(a[53]=l('<p>有一个变动：移除了 <code>ScopedValue</code> 类中的 <code>callWhere</code> 和 <code>runWhere</code> 方法，使 API 保持完全流畅的链式调用特性。现在使用一个或多个绑定作用域值的唯一方式是通过 <code>ScopedValue.Carrier.call</code> 和 <code>ScopedValue.Carrier.run</code> 方法。</p><h2 id="jep-488-模式、instanceof-和-switch中的原始类型-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-488-模式、instanceof-和-switch中的原始类型-第二次预览"><span>JEP 488: 模式、instanceof 和 switch中的原始类型（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 488: Primitive Types in Patterns, instanceof, and switch (Second Preview)</p><p>Enhance pattern matching by allowing primitive types in all pattern contexts, and extend instanceof and switch to work with all primitive types. This is a preview language feature.</p></div><p>通过允许在所有模式上下文中使用原始类型来增强模式匹配，并扩展 instanceof 和 switch 以使用所有原始类型。这是一个预览语言功能。</p><p>在所有模式上下文中允许<strong>原始类型模式与对应包装类型之间的宽松转换</strong>，并支持<strong>对记录组件的类型宽松匹配</strong>。核心贡献是：</p><ul><li>原始类型模式与应包装类型之间的宽松转换 <ul><li>增强 instanceof 和 switch 构造以支持原始类型模式作为顶级模式：允许在模式匹配中直接使用原始类型（如 <code>int p</code>）来匹配包装类（如 <code>Integer</code>）的对象。</li><li>增强记录模式以支持类型转换：允许在记录模式中使用原始类型来匹配包装类型的记录组件值，无需严格匹配包装类型。</li></ul></li><li>对记录组件的类型宽松匹配：在记录模式中使用原始类型来匹配记录的组件值时，无需严格匹配原始类型。这一机制支持在解构记录时自动完成原始类型的加宽转换和有条件的安全缩窄转换，显著提升了代码的简洁性与灵活性。</li><li>安全性 <ul><li>妥善处理 null 值，原始类型模式不会匹配 null，从而避免了潜在的 NullPointerException。</li><li>对于记录模式中可能造成信息丢失的缩窄转换（如 double → int），模式匹配会在运行时自动检查值的兼容性，仅在不丢失信息时完成匹配，否则返回 false，保障匹配过程的安全性与可靠性。</li></ul></li><li>语法与一致性更新：引入了相应的支配性检查规则，在同一个 switch 块中，原始类型模式（如 int i）和其对应的包装类型模式（如 Integer i）不能同时存在，因为它们会互相导致对方不可到达，无论顺序如何都会编译报错。记录模式也遵循相同的类型转换原则，进一步强化了模式匹配整体的语言一致性和表达力。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>模式 (Pattern)是一个通用概念，指的是在条件判断中同时进行类型检查和变量绑定的操作。例如：obj instanceof String s 就是一个类型模式，它同时检查 obj 是否是 String 类型，如果是，则将其绑定到变量 s。</p><p>instanceof 运算符是应用类型模式的第一个地方。从 Java 16 开始，instanceof 后面可以直接跟一个类型模式和变量名。</p><p>switch 表达式/语句是应用多种模式（包括类型模式、常量模式等）的更强大场所。在 Java 17 和 21 中，switch 的能力被大幅增强，case 标签可以支持模式。</p><p>所以三者关系是：模式匹配是一个范式；instanceof 和 switch 是应用该范式的语法工具。</p><p>因此，对JEP 488最准确的理解是：为模式、instanceof 和 switch 添加对原始类型的支持。</p></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>自动加宽转换： 使用一个“较宽”的类型模式 (double) 去匹配一个“较窄”的组件类型 (int) 的值。编译器允许这种操作，并自动完成安全的值转换。</p><p>有条件的安全缩窄转换： 缩窄转换是一种可能丢失信息的转换（例如，将 double 3.14 转换为 int 3 会丢失小数部分），因此不是无条件进行的。</p><ul><li>JVM 会先检查这个 double 值是否能完全精确地转换为一个 int 值（即没有小数部分，且在 int 的取值范围内）</li><li>如果检查通过：模式匹配成功，变量被赋值</li><li>如果检查不通过（值太大或有小数）：模式匹配直接返回 false，不会赋值，也不会抛出异常</li></ul><p>注意：</p><ul><li>“自动加宽转换”和“有条件的安全缩窄转换”要求初始类型和目标类型都是原始类型。</li></ul></div>',8)),n("p",null,[t(o,{to:"/java/new-features/primitive-types-in-patterns-instanceof-and-switch.html"},{default:s(()=>a[42]||(a[42]=[e("模式、instanceof 和 switch中的原始类型")])),_:1,__:[42]})]),a[54]||(a[54]=l(`<h2 id="jep-489-向量-api-第九个孵化器" tabindex="-1"><a class="header-anchor" href="#jep-489-向量-api-第九个孵化器"><span>JEP 489: 向量 API（第九个孵化器）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 489: Vector API (Ninth Incubator)</p><p>Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations.</p></div><p>引入一个 API 来表达矢量计算，这些计算在运行时可靠地编译为受支持的 CPU 上的最佳矢量指令，从而实现优于等效标量计算的性能。</p><h2 id="jep-490-zgc-删除非分代模式" tabindex="-1"><a class="header-anchor" href="#jep-490-zgc-删除非分代模式"><span>JEP 490: ZGC：删除非分代模式</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 490: ZGC: Remove the Non-Generational Mode</p><p>Remove the non-generational mode of the Z Garbage Collector (ZGC), keeping the generational mode as the default for ZGC.</p></div><p>移除Z垃圾回收器（ZGC）的非分代模式，保留分代模式作为ZGC的默认配置。</p><h2 id="jep-491-无需固定即可同步虚拟线程" tabindex="-1"><a class="header-anchor" href="#jep-491-无需固定即可同步虚拟线程"><span>JEP 491: 无需固定即可同步虚拟线程</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 491: Synchronize Virtual Threads without Pinning</p><p>Improve the scalability of Java code that uses synchronized methods and statements by arranging for virtual threads that block in such constructs to release their underlying platform threads for use by other virtual threads. This will eliminate nearly all cases of virtual threads being pinned to platform threads, which severely restricts the number of virtual threads available to handle an application&#39;s workload.</p></div><p>本改进旨在提升使用同步方法和语句的Java代码的可扩展性。其机制是：当虚拟线程在此类同步结构中阻塞时，会主动释放其占用的平台线程，以供其他虚拟线程使用。此举将消除虚拟线程被“固定”在平台线程上的绝大多数情况，从而避免其对应用工作负载处理能力的严重限制。</p><h2 id="jep-492-灵活的构造函数体-第三次预览" tabindex="-1"><a class="header-anchor" href="#jep-492-灵活的构造函数体-第三次预览"><span>JEP 492: 灵活的构造函数体（第三次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 492: Flexible Constructor Bodies (Third Preview)</p><p>In constructors in the Java programming language, allow statements to appear before an explicit constructor invocation, i.e., super(..) or this(..). The statements cannot reference the instance under construction, but they can initialize its fields. Initializing fields before invoking another constructor makes a class more reliable when methods are overridden. This is a preview language feature.</p></div><p>在 Java 编程语言的构造函数中，允许在显式构造函数调用（即 super(..) 或 this(..)）之前出现语句。这些语句不能引用正在构建的实例，但可以初始化其字段。在调用另一个构造函数之前初始化字段，可以在方法被重写时提高类的可靠性。这是一个预览语言特性。</p><h2 id="jep-493-无需-jmod-即可链接运行时图像" tabindex="-1"><a class="header-anchor" href="#jep-493-无需-jmod-即可链接运行时图像"><span>JEP 493: 无需 JMOD 即可链接运行时图像</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 493: Linking Run-Time Images without JMODs</p><p>Reduce the size of the JDK by approximately 25% by enabling the jlink tool to create custom run-time images without using the JDK&#39;s JMOD files. This feature must be enabled when the JDK is built; it will not be enabled by default, and some JDK vendors may choose not to enable it.</p></div><p>通过让 jlink 工具能够在不依赖 JDK 的 JMOD 文件的情况下创建自定义运行时镜像，可将 JDK 的体积减小约 25%。此功能需在构建 JDK 时手动启用，它不会默认生效，且部分 JDK 供应商可能会选择不启用它。</p><h2 id="jep-494-模块导入声明-第二次预览" tabindex="-1"><a class="header-anchor" href="#jep-494-模块导入声明-第二次预览"><span>JEP 494: 模块导入声明（第二次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 494: Module Import Declarations (Second Preview)</p><p>Enhance the Java programming language with the ability to succinctly import all of the packages exported by a module. This simplifies the reuse of modular libraries, but does not require the importing code to be in a module itself. This is a preview language feature.</p></div><p>增强 Java 编程语言，使其能够简洁地导入某个模块所导出的所有包。这简化了模块化库的重用，且调用方代码自身不必是模块化的。这是一项预览语言特性。</p><p><strong>使用新特性导入整个模块</strong> 假设有一个名为 com.example.utils 的模块，其 module-info.java 文件导出了了一些包：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// module-info.java</span></span>
<span class="line"><span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在另一个非模块化的应用程序（即没有 module-info.java）中，现在可以使用一种新的导入语句来一次性导入 com.example.utils 模块导出的所有包。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token comment">// 使用 &#39;import module&#39; 关键字一次性导入整个模块的所有导出包</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token keyword">module</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 现在可以直接使用被导入模块中所有导出包下的类，而无需逐个导入</span></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.math 包</span></span>
<span class="line">    <span class="token class-name">Calculator</span> calc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">double</span> result <span class="token operator">=</span> calc<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 来自 com.example.utils.logging 包</span></span>
<span class="line">    <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Logger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;Result is: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>与之前方式的对比</strong></p>`,23)),n("ul",null,[a[48]||(a[48]=l(`<li>方式一（传统非模块化项目）： 必须逐个导入所需的每个类或包。<div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">Calculator</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>logging<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// ... 还需要导入其他要用的类 ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,1)),n("li",null,[a[47]||(a[47]=e("方式二（模块化项目）： 即使只想用一两个类，也必须在自己的 module-info.java 中声明对整个模块的依赖。")),t(c,{id:"904",data:[{id:"module-info.java"},{id:"MyApp.java"}]},{title0:s(({value:p,isActive:r})=>a[43]||(a[43]=[e("module-info.java")])),title1:s(({value:p,isActive:r})=>a[44]||(a[44]=[e("MyApp.java")])),tab0:s(({value:p,isActive:r})=>a[45]||(a[45]=[n("div",{class:"language-java line-numbers-mode","data-highlighter":"prismjs","data-ext":"java"},[n("pre",null,[n("code",null,[n("span",{class:"line"},[n("span",{class:"token keyword"},"module"),e(),n("span",{class:"token namespace"},[e("my"),n("span",{class:"token punctuation"},"."),e("app")]),e(),n("span",{class:"token punctuation"},"{")]),e(`
`),n("span",{class:"line"},[e("  "),n("span",{class:"token keyword"},"requires"),e(),n("span",{class:"token namespace"},[e("com"),n("span",{class:"token punctuation"},"."),e("example"),n("span",{class:"token punctuation"},"."),e("utils")]),n("span",{class:"token punctuation"},";")]),e(`
`),n("span",{class:"line"},[e("  "),n("span",{class:"token comment"},"// ... 其他依赖 ...")]),e(`
`),n("span",{class:"line"},[n("span",{class:"token punctuation"},"}")]),e(`
`),n("span",{class:"line"})])]),n("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1)])),tab1:s(({value:p,isActive:r})=>a[46]||(a[46]=[n("div",{class:"language-java line-numbers-mode","data-highlighter":"prismjs","data-ext":"java"},[n("pre",null,[n("code",null,[n("span",{class:"line"},[n("span",{class:"token keyword"},"import"),e(),n("span",{class:"token namespace"},[e("com"),n("span",{class:"token punctuation"},"."),e("example"),n("span",{class:"token punctuation"},"."),e("utils"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token punctuation"},"."),e("math"),n("span",{class:"token punctuation"},"."),e("Calculator"),n("span",{class:"token punctuation"},";")]),e(`
`),n("span",{class:"line"})])]),n("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[n("div",{class:"line-number"})])],-1)])),_:1})]),a[49]||(a[49]=n("li",null,[e("使用新特性后的方式（简洁且无需模块化）： "),n("ul",null,[n("li",null,"无需自身的 module-info.java。"),n("li",null,"一行语句 import module com.example.utils.*; 即可获得该模块所有导出包的访问权，无需再写多个 import 语句。")])],-1))]),a[55]||(a[55]=l(`<p>之前在 JDK 23 中预览过，本次改动点：</p><ul><li>解除任何模块都不能声明对 java.base 模块的传递依赖的限制</li><li>修改 java.se 模块的声明</li><li>允许 type-import-on-demand 声明遮蔽模块导入声明</li></ul><h2 id="jep-495-简单源文件和实例主方法-第四次预览" tabindex="-1"><a class="header-anchor" href="#jep-495-简单源文件和实例主方法-第四次预览"><span>JEP 495: 简单源文件和实例主方法（第四次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)</p><p>Evolve the Java programming language so that beginners can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of the language, beginners can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. Experienced developers can likewise enjoy writing small programs succinctly, without the need for constructs intended for programming in the large. This is a preview language feature.</p></div><p>扩展 Java 编程语言，使初学者无需了解专为大型程序设计的语言功能，即可编写自己的第一个程序。初学者无需使用某种独立的语言变体，即可为单类程序编写简化的声明，然后随着技能的增长无缝扩展他们的程序以使用更高级的功能。经验丰富的开发者同样可以简洁地编写小型程序，而不必使用那些为大规模编程设计的结构。</p><p>简单说就是省略显式类声明和 public static 修饰符，简化输出语句，来简化入门代码和脚本开发。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello Java 23!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式调用 System.out.println</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改动点：将<strong>隐式声明的类和实例主方法</strong>重命名为<strong>简单源文件和实例主要方法</strong></p><h2 id="jep-496-基于抗量子模块格的密钥封装机制" tabindex="-1"><a class="header-anchor" href="#jep-496-基于抗量子模块格的密钥封装机制"><span>JEP 496: 基于抗量子模块格的密钥封装机制</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 496: Quantum-Resistant Module-Lattice-Based Key Encapsulation Mechanism</p><p>Enhance the security of Java applications by providing an implementation of the quantum-resistant Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). Key encapsulation mechanisms (KEMs) are used to secure symmetric keys over insecure communication channels using public key cryptography. ML-KEM is designed to be secure against future quantum computing attacks. It has been standardized by the United States National Institute of Standards and Technology (NIST) in FIPS 203.</p></div><p>通过提供抗量子的基于模块格的密钥封装机制（ML-KEM）实现，增强Java应用程序的安全性。密钥封装机制（KEM）利用公钥密码学，在不安全通信信道中保护对称密钥的安全传输。ML-KEM的设计旨在抵御未来量子计算攻击，并已由美国国家标准与技术研究院（NIST）在FIPS 203中完成标准化。</p><h2 id="jep-497-基于模块格的抗量子数字签名算法" tabindex="-1"><a class="header-anchor" href="#jep-497-基于模块格的抗量子数字签名算法"><span>JEP 497: 基于模块格的抗量子数字签名算法</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 497: Quantum-Resistant Module-Lattice-Based Digital Signature Algorithm</p><p>Enhance the security of Java applications by providing an implementation of the quantum-resistant Module-Lattice-Based Digital Signature Algorithm (ML-DSA). Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of signatories. ML-DSA is designed to be secure against future quantum computing attacks. It has been standardized by the United States National Institute of Standards and Technology (NIST) in FIPS 204.</p></div><p>通过提供抗量子计算的基于模块格的数字签名算法（ML-DSA）实现，增强Java应用程序的安全性。数字签名技术用于检测数据的非法篡改，并对签名者身份进行认证。ML-DSA的设计旨在抵御未来量子计算攻击，并已由美国国家标准与技术研究院（NIST）在FIPS 204中完成标准化。</p><h2 id="jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告" tabindex="-1"><a class="header-anchor" href="#jep-498-在-sun-misc-unsafe-中使用内存访问方法时发出警告"><span>JEP 498: 在 sun.misc.Unsafe 中使用内存访问方法时发出警告</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 498: Warn upon Use of Memory-Access Methods in sun.misc.Unsafe</p><p>Issue a warning at run time on the first occasion that any memory-access method in sun.misc.Unsafe is invoked. All of these unsupported methods were terminally deprecated in JDK 23. They have been superseded by standard APIs, namely the VarHandle API (JEP 193, JDK 9) and the Foreign Function &amp; Memory API (JEP 454, JDK 22). We strongly encourage library developers to migrate from sun.misc.Unsafe to supported replacements, so that applications can migrate smoothly to modern JDK releases.</p></div><p>在运行时首次调用 sun.misc.Unsafe 中的任何内存访问方法时发出警告。 所有这些不受支持的方法已在 JDK 23 中被最终标记为弃用。它们已被标准 API 所取代，即 VarHandle API（JEP 193，JDK 9）和外部函数与内存 API（JEP 454，JDK 22）。强烈建议库开发者从 sun.misc.Unsafe 迁移至受支持的替代方案，以确保应用能够顺利过渡到现代 JDK 版本。</p><blockquote><p>创建 sun.misc.Unsafe 类是为了为 Java 类提供一种执行低级操作的机制。它的大多数方法用于访问内存，无论是在 JVM 的垃圾收集堆中还是在堆外内存中，这些内存不受 JVM 控制。正如类名所示，这些内存访问方法是不安全的。</p></blockquote><h2 id="jep-499-结构化并发-第四次预览" tabindex="-1"><a class="header-anchor" href="#jep-499-结构化并发-第四次预览"><span>JEP 499: 结构化并发（第四次预览）</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 499: Structured Concurrency (Fourth Preview)</p><p>Simplify concurrent programming by introducing an API for structured concurrency. Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API.</p></div><p>通过引入结构化并发 API 来简化并发编程。结构化并发将不同线程中运行的相关任务组视为单个工作单元，从而简化错误处理和取消，提高可靠性并增强可观测性。这是一个预览 API。</p><h2 id="jep-501-弃用-32-位-x86-端口并将其删除" tabindex="-1"><a class="header-anchor" href="#jep-501-弃用-32-位-x86-端口并将其删除"><span>JEP 501: 弃用 32 位 x86 端口并将其删除</span></a></h2><div class="hint-container info"><p class="hint-container-title">JEP 501: Deprecate the 32-bit x86 Port for Removal</p><p>Deprecate the 32-bit x86 port, with the intent to remove it in a future release. This will thereby deprecate the Linux 32-bit x86 port, which is the only 32-bit x86 port remaining in the JDK. It will also, effectively, deprecate any remaining downstream 32-bit x86 ports. After the 32-bit x86 port is removed, the architecture-agnostic Zero port will be the only way to run Java programs on 32-bit x86 processors.</p></div><p>弃用 32 位 x86 端口，并计划在未来版本中将其移除。此举将导致目前 JDK 中唯一剩余的 32 位 x86 端口——Linux 32 位 x86 端口被弃用，同时也将实质上弃用所有下游衍生的 32 位 x86 移植版本。在该端口被移除后，与架构无关的 Zero 移植版本将成为在 32 位 x86 处理器上运行 Java 程序的唯一方式。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://openjdk.org/projects/jdk/24/" target="_blank" rel="noopener noreferrer">JDK 24</a></p>`,26))])}const k=u(v,[["render",f]]),y=JSON.parse('{"path":"/java/new-features/java-24-features.html","title":"Java 24 新特性","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1758607541000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":4,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"45e9da4f9c89c3a73aba5fd1e310a07b0499f433","time":1758607541000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 新特性"},{"hash":"18f0d4a4f1d4c588016a7d0c04145c1731b60fee","time":1757924168000,"email":"3036190149@qq.com","author":"zhaomy","message":"java22新特性 &#x26; java23-25新特性修改"},{"hash":"a56dd23708c5d2f36ccc4bf8fe2380b4e747453c","time":1757919595000,"email":"3036190149@qq.com","author":"zhaomy","message":"java24、java25新特性修改"},{"hash":"0b4ed712e028b2125ee6f1e073cdfe17b60eaeb8","time":1757914089000,"email":"3036190149@qq.com","author":"zhaomy","message":"java 24 、java25 新特性"}]},"filePathRelative":"java/new-features/java-24-features.md","excerpt":"\\n\\n<h2>概述</h2>\\n<p>Java 24 于 2025 年 3 月发布，该版本提供24项新特性（含10项孵化/预览/实验功能）</p>\\n<h2>JEP 404: 分代 Shenandoah（实验性）</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">JEP 404: Generational Shenandoah (Experimental)</p>\\n<p>Enhance the Shenandoah garbage collector with experimental generational collection capabilities to improve sustainable throughput, load-spike resilience, and memory utilization.</p>\\n</div>"}');export{k as comp,y as data};
