import{_ as d,c as i,a as n,d as r,e as s,w as h,r as t,o,b as e}from"./app-C07FBv5C.js";const p={},f={class:"table-of-contents"};function u(b,a){const l=t("router-link");return o(),i("div",null,[a[45]||(a[45]=n("h1",{id:"数据结构与算法",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#数据结构与算法"},[n("span",null,"数据结构与算法")])],-1)),n("nav",f,[n("ul",null,[n("li",null,[s(l,{to:"#数据结构"},{default:h(()=>a[0]||(a[0]=[e("数据结构")])),_:1,__:[0]}),n("ul",null,[n("li",null,[s(l,{to:"#线性表"},{default:h(()=>a[1]||(a[1]=[e("线性表")])),_:1,__:[1]})]),n("li",null,[s(l,{to:"#堆"},{default:h(()=>a[2]||(a[2]=[e("堆")])),_:1,__:[2]})]),n("li",null,[s(l,{to:"#树"},{default:h(()=>a[3]||(a[3]=[e("树")])),_:1,__:[3]})]),n("li",null,[s(l,{to:"#图"},{default:h(()=>a[4]||(a[4]=[e("图")])),_:1,__:[4]})]),n("li",null,[s(l,{to:"#其他"},{default:h(()=>a[5]||(a[5]=[e("其他")])),_:1,__:[5]})])])]),n("li",null,[s(l,{to:"#排序"},{default:h(()=>a[6]||(a[6]=[e("排序")])),_:1,__:[6]}),n("ul",null,[n("li",null,[s(l,{to:"#冒泡排序"},{default:h(()=>a[7]||(a[7]=[e("冒泡排序")])),_:1,__:[7]})]),n("li",null,[s(l,{to:"#插入排序"},{default:h(()=>a[8]||(a[8]=[e("插入排序")])),_:1,__:[8]})]),n("li",null,[s(l,{to:"#shell排序"},{default:h(()=>a[9]||(a[9]=[e("Shell排序")])),_:1,__:[9]})]),n("li",null,[s(l,{to:"#快速排序"},{default:h(()=>a[10]||(a[10]=[e("快速排序")])),_:1,__:[10]})]),n("li",null,[s(l,{to:"#堆排序"},{default:h(()=>a[11]||(a[11]=[e("堆排序")])),_:1,__:[11]})]),n("li",null,[s(l,{to:"#归并排序"},{default:h(()=>a[12]||(a[12]=[e("归并排序")])),_:1,__:[12]})]),n("li",null,[s(l,{to:"#计数排序"},{default:h(()=>a[13]||(a[13]=[e("计数排序")])),_:1,__:[13]})]),n("li",null,[s(l,{to:"#基数排序"},{default:h(()=>a[14]||(a[14]=[e("基数排序")])),_:1,__:[14]})]),n("li",null,[s(l,{to:"#桶排序"},{default:h(()=>a[15]||(a[15]=[e("桶排序")])),_:1,__:[15]})]),n("li",null,[s(l,{to:"#总结"},{default:h(()=>a[16]||(a[16]=[e("总结")])),_:1,__:[16]})])])]),n("li",null,[s(l,{to:"#中位数和顺序统计量"},{default:h(()=>a[17]||(a[17]=[e("中位数和顺序统计量")])),_:1,__:[17]}),n("ul",null,[n("li",null,[s(l,{to:"#最小值和最大值"},{default:h(()=>a[18]||(a[18]=[e("最小值和最大值")])),_:1,__:[18]})]),n("li",null,[s(l,{to:"#期望为线性时间的选择算法"},{default:h(()=>a[19]||(a[19]=[e("期望为线性时间的选择算法")])),_:1,__:[19]})]),n("li",null,[s(l,{to:"#最坏情况为线性时间的选择算法"},{default:h(()=>a[20]||(a[20]=[e("最坏情况为线性时间的选择算法")])),_:1,__:[20]})])])]),n("li",null,[s(l,{to:"#算法思想"},{default:h(()=>a[21]||(a[21]=[e("算法思想")])),_:1,__:[21]}),n("ul",null,[n("li",null,[s(l,{to:"#分治算法"},{default:h(()=>a[22]||(a[22]=[e("分治算法")])),_:1,__:[22]})]),n("li",null,[s(l,{to:"#动态规划"},{default:h(()=>a[23]||(a[23]=[e("动态规划")])),_:1,__:[23]})]),n("li",null,[s(l,{to:"#贪心算法"},{default:h(()=>a[24]||(a[24]=[e("贪心算法")])),_:1,__:[24]})]),n("li",null,[s(l,{to:"#摊还算法"},{default:h(()=>a[25]||(a[25]=[e("摊还算法")])),_:1,__:[25]})]),n("li",null,[s(l,{to:"#最大流"},{default:h(()=>a[26]||(a[26]=[e("最大流")])),_:1,__:[26]})]),n("li",null,[s(l,{to:"#二分法"},{default:h(()=>a[27]||(a[27]=[e("二分法")])),_:1,__:[27]})]),n("li",null,[s(l,{to:"#搜索算法"},{default:h(()=>a[28]||(a[28]=[e("搜索算法")])),_:1,__:[28]})]),n("li",null,[s(l,{to:"#回溯算法"},{default:h(()=>a[29]||(a[29]=[e("回溯算法")])),_:1,__:[29]})])])]),n("li",null,[s(l,{to:"#算法问题选编"},{default:h(()=>a[30]||(a[30]=[e("算法问题选编")])),_:1,__:[30]}),n("ul",null,[n("li",null,[s(l,{to:"#多线程算法"},{default:h(()=>a[31]||(a[31]=[e("多线程算法")])),_:1,__:[31]})]),n("li",null,[s(l,{to:"#矩阵运算"},{default:h(()=>a[32]||(a[32]=[e("矩阵运算")])),_:1,__:[32]})]),n("li",null,[s(l,{to:"#线性规划"},{default:h(()=>a[33]||(a[33]=[e("线性规划")])),_:1,__:[33]})]),n("li",null,[s(l,{to:"#多项式与快速傅里叶变换"},{default:h(()=>a[34]||(a[34]=[e("多项式与快速傅里叶变换")])),_:1,__:[34]})]),n("li",null,[s(l,{to:"#数论算法"},{default:h(()=>a[35]||(a[35]=[e("数论算法")])),_:1,__:[35]})]),n("li",null,[s(l,{to:"#字符串匹配"},{default:h(()=>a[36]||(a[36]=[e("字符串匹配")])),_:1,__:[36]})]),n("li",null,[s(l,{to:"#计算几何学"},{default:h(()=>a[37]||(a[37]=[e("计算几何学")])),_:1,__:[37]})]),n("li",null,[s(l,{to:"#np完全性"},{default:h(()=>a[38]||(a[38]=[e("NP完全性")])),_:1,__:[38]})]),n("li",null,[s(l,{to:"#近似算法"},{default:h(()=>a[39]||(a[39]=[e("近似算法")])),_:1,__:[39]})])])]),n("li",null,[s(l,{to:"#领域算法"},{default:h(()=>a[40]||(a[40]=[e("领域算法")])),_:1,__:[40]}),n("ul",null,[n("li",null,[s(l,{to:"#安全算法"},{default:h(()=>a[41]||(a[41]=[e("安全算法")])),_:1,__:[41]})]),n("li",null,[s(l,{to:"#大数据处理"},{default:h(()=>a[42]||(a[42]=[e("大数据处理")])),_:1,__:[42]})]),n("li",null,[s(l,{to:"#分布式算法"},{default:h(()=>a[43]||(a[43]=[e("分布式算法")])),_:1,__:[43]})]),n("li",null,[s(l,{to:"#负载均衡算法"},{default:h(()=>a[44]||(a[44]=[e("负载均衡算法")])),_:1,__:[44]})])])])])]),a[46]||(a[46]=r('<h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h3 id="线性表" tabindex="-1"><a class="header-anchor" href="#线性表"><span>线性表</span></a></h3><h4 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h4><h4 id="链表" tabindex="-1"><a class="header-anchor" href="#链表"><span>链表</span></a></h4><h4 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表"><span>哈希表</span></a></h4><h3 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h3><h4 id="斐波那契堆" tabindex="-1"><a class="header-anchor" href="#斐波那契堆"><span>斐波那契堆</span></a></h4><h3 id="树" tabindex="-1"><a class="header-anchor" href="#树"><span>树</span></a></h3><h4 id="二叉搜索树-bst" tabindex="-1"><a class="header-anchor" href="#二叉搜索树-bst"><span>二叉搜索树（BST）</span></a></h4><h4 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树"><span>平衡二叉树</span></a></h4><h4 id="红黑树" tabindex="-1"><a class="header-anchor" href="#红黑树"><span>红黑树</span></a></h4><h4 id="哈夫曼树" tabindex="-1"><a class="header-anchor" href="#哈夫曼树"><span>哈夫曼树</span></a></h4><h4 id="前缀树" tabindex="-1"><a class="header-anchor" href="#前缀树"><span>前缀树</span></a></h4><h4 id="b树" tabindex="-1"><a class="header-anchor" href="#b树"><span>B树</span></a></h4><h4 id="van-emde-boas-树" tabindex="-1"><a class="header-anchor" href="#van-emde-boas-树"><span>van Emde Boas 树</span></a></h4><h3 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h3><h4 id="wfs" tabindex="-1"><a class="header-anchor" href="#wfs"><span>WFS</span></a></h4><h4 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs"><span>BFS</span></a></h4><h4 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树"><span>最小生成树</span></a></h4><h4 id="最短路径-dijkstra-frolyd" tabindex="-1"><a class="header-anchor" href="#最短路径-dijkstra-frolyd"><span>最短路径（Dijkstra &amp; Frolyd）</span></a></h4><h4 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序"><span>拓扑排序</span></a></h4><h4 id="所有节点对的最短路径" tabindex="-1"><a class="header-anchor" href="#所有节点对的最短路径"><span>所有节点对的最短路径</span></a></h4><h4 id="aoe-关键路径" tabindex="-1"><a class="header-anchor" href="#aoe-关键路径"><span>AOE &amp; 关键路径</span></a></h4><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3><h4 id="用于不相交集合的数据结构" tabindex="-1"><a class="header-anchor" href="#用于不相交集合的数据结构"><span>用于不相交集合的数据结构</span></a></h4><hr><h2 id="排序" tabindex="-1"><a class="header-anchor" href="#排序"><span>排序</span></a></h2><h3 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h3><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序"><span>插入排序</span></a></h3><h3 id="shell排序" tabindex="-1"><a class="header-anchor" href="#shell排序"><span>Shell排序</span></a></h3><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h3><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h3><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h3><h3 id="计数排序" tabindex="-1"><a class="header-anchor" href="#计数排序"><span>计数排序</span></a></h3><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序"><span>基数排序</span></a></h3><h3 id="桶排序" tabindex="-1"><a class="header-anchor" href="#桶排序"><span>桶排序</span></a></h3><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | | --- | --- | | 插入排序 | O(n^2) | O(1) | 稳定 | | 堆排序 | O(nlogn) | O(1) | 不稳定 | | 快速排序 | O(nlogn) | O(logn) | 不稳定 | | 计数排序 | O(n+k) | O(k) | 不稳定 | | 基数排序 | O(dn) | O(n+k) | 稳定 | | 桶排序 | O(n+k) | O(n+k) | 不稳定 |</p><p>线性时间排序：计数排序、基数排序、桶排序 稳定排序：插入排序、基数排序</p><hr><h2 id="中位数和顺序统计量" tabindex="-1"><a class="header-anchor" href="#中位数和顺序统计量"><span>中位数和顺序统计量</span></a></h2><h3 id="最小值和最大值" tabindex="-1"><a class="header-anchor" href="#最小值和最大值"><span>最小值和最大值</span></a></h3><h3 id="期望为线性时间的选择算法" tabindex="-1"><a class="header-anchor" href="#期望为线性时间的选择算法"><span>期望为线性时间的选择算法</span></a></h3><h3 id="最坏情况为线性时间的选择算法" tabindex="-1"><a class="header-anchor" href="#最坏情况为线性时间的选择算法"><span>最坏情况为线性时间的选择算法</span></a></h3><hr><h2 id="算法思想" tabindex="-1"><a class="header-anchor" href="#算法思想"><span>算法思想</span></a></h2><h3 id="分治算法" tabindex="-1"><a class="header-anchor" href="#分治算法"><span>分治算法</span></a></h3><p>分治算法将原问题划分为互不相交的子问题，递归地求解子问题，再将它们组合起来，求出原问题的解。</p><h3 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h3><h3 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法"><span>贪心算法</span></a></h3><p>贪心算法的思想是保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。贪心算法对很多问题都能求得最优解，而且速度比动态规划算法更快，但是并不是所有问题都能用贪心算法求解。贪心算法常见的问题有：</p><ul><li>找零问题</li></ul><h3 id="摊还算法" tabindex="-1"><a class="header-anchor" href="#摊还算法"><span>摊还算法</span></a></h3><h3 id="最大流" tabindex="-1"><a class="header-anchor" href="#最大流"><span>最大流</span></a></h3><h3 id="二分法" tabindex="-1"><a class="header-anchor" href="#二分法"><span>二分法</span></a></h3><h3 id="搜索算法" tabindex="-1"><a class="header-anchor" href="#搜索算法"><span>搜索算法</span></a></h3><h3 id="回溯算法" tabindex="-1"><a class="header-anchor" href="#回溯算法"><span>回溯算法</span></a></h3><hr><h2 id="算法问题选编" tabindex="-1"><a class="header-anchor" href="#算法问题选编"><span>算法问题选编</span></a></h2><h3 id="多线程算法" tabindex="-1"><a class="header-anchor" href="#多线程算法"><span>多线程算法</span></a></h3><h3 id="矩阵运算" tabindex="-1"><a class="header-anchor" href="#矩阵运算"><span>矩阵运算</span></a></h3><h3 id="线性规划" tabindex="-1"><a class="header-anchor" href="#线性规划"><span>线性规划</span></a></h3><h3 id="多项式与快速傅里叶变换" tabindex="-1"><a class="header-anchor" href="#多项式与快速傅里叶变换"><span>多项式与快速傅里叶变换</span></a></h3><h3 id="数论算法" tabindex="-1"><a class="header-anchor" href="#数论算法"><span>数论算法</span></a></h3><h3 id="字符串匹配" tabindex="-1"><a class="header-anchor" href="#字符串匹配"><span>字符串匹配</span></a></h3><ul><li>朴素算法</li><li>KMP算法</li><li>BM算法</li><li>后缀树</li></ul><h3 id="计算几何学" tabindex="-1"><a class="header-anchor" href="#计算几何学"><span>计算几何学</span></a></h3><h3 id="np完全性" tabindex="-1"><a class="header-anchor" href="#np完全性"><span>NP完全性</span></a></h3><h3 id="近似算法" tabindex="-1"><a class="header-anchor" href="#近似算法"><span>近似算法</span></a></h3><h2 id="领域算法" tabindex="-1"><a class="header-anchor" href="#领域算法"><span>领域算法</span></a></h2><h3 id="安全算法" tabindex="-1"><a class="header-anchor" href="#安全算法"><span>安全算法</span></a></h3><p>摘要算法 加密算法 国密算法</p><h3 id="大数据处理" tabindex="-1"><a class="header-anchor" href="#大数据处理"><span>大数据处理</span></a></h3><ul><li>分治、哈希、排序</li><li>Bitmap &amp; Bloom Filter</li><li>双层桶划分</li><li>Trie树、数据库、倒排索引</li><li>外排序</li><li>Map &amp; Reduce</li></ul><h3 id="分布式算法" tabindex="-1"><a class="header-anchor" href="#分布式算法"><span>分布式算法</span></a></h3><ul><li>一致性Hash算法</li><li>Paxos算法</li><li>Raft算法</li><li>ZAB算法</li><li>Snowflake算法</li><li>Gossip协议</li></ul><h3 id="负载均衡算法" tabindex="-1"><a class="header-anchor" href="#负载均衡算法"><span>负载均衡算法</span></a></h3>',77))])}const _=d(p,[["render",u]]),m=JSON.parse('{"path":"/posts/algorithm/","title":"算法","lang":"zh-CN","frontmatter":{"title":"算法","date":"2025-07-07T08:20:31.000Z","category":["algorithm"],"tags":["algorithm"]},"git":{"updatedTime":1752195777000,"contributors":[{"name":"zhaomy","username":"zhaomy","email":"3036190149@qq.com","commits":1,"url":"https://github.com/zhaomy"}],"changelog":[{"hash":"e5db736c87d043812b2106b05ada7017fab60b62","time":1752195777000,"email":"3036190149@qq.com","author":"zhaomy","message":"1、目录调整 2、算法：动态规划、领域算法-负载均衡 3、Nginx负载均衡、配置文件"}]},"filePathRelative":"posts/algorithm/index.md","excerpt":"\\n\\n<h2>数据结构</h2>\\n<h3>线性表</h3>\\n<h4>栈和队列</h4>\\n<h4>链表</h4>\\n<h4>哈希表</h4>\\n<h3>堆</h3>\\n<h4>斐波那契堆</h4>\\n<h3>树</h3>\\n<h4>二叉搜索树（BST）</h4>\\n<h4>平衡二叉树</h4>\\n<h4>红黑树</h4>\\n<h4>哈夫曼树</h4>\\n<h4>前缀树</h4>\\n<h4>B树</h4>\\n<h4>van Emde Boas 树</h4>\\n<h3>图</h3>\\n<h4>WFS</h4>\\n<h4>BFS</h4>\\n<h4>最小生成树</h4>\\n<h4>最短路径（Dijkstra &amp; Frolyd）</h4>"}');export{_ as comp,m as data};
